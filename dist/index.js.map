{"version":3,"file":"index.js","sources":["../libs/pre-conversion-subs/utils.ts","../libs/pre-conversion-subs/break-on-boundaries.ts","../libs/pretext-subs/to-pretext.ts","../libs/split-for-pars.ts","../libs/wrap-pars.ts","../libs/pre-conversion-subs/create-table-from-tabular.ts","../libs/pre-conversion-subs/environment-subs.ts","../libs/pre-conversion-subs/katex-subs.ts","../libs/pre-conversion-subs/macro-subs.ts","../libs/pre-conversion-subs/streaming-command-subs.ts","../libs/unified-latex-wrap-pars.ts","../libs/pre-conversion-subs/report-unsupported-macro-katex.ts","../libs/unified-latex-plugin-to-pretext-like.ts","../libs/pre-conversion-subs/expand-user-defined-macros.ts","../libs/unified-latex-plugin-to-pretext.ts","../libs/convert-to-pretext.ts"],"sourcesContent":["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport { VFile } from \"vfile\";\nimport { s } from \"@unified-latex/unified-latex-builder\";\nimport { VFileMessage } from \"vfile-message\";\n\n/**\n * Create a warning message about node from the given source file.\n */\nexport function makeWarningMessage(\n    node: Ast.Node,\n    message: string,\n    warningType: string\n): VFileMessage {\n    const newMessage = new VFileMessage(message, node);\n\n    newMessage.source = `unified-latex-to-pretext:${warningType}`;\n\n    return newMessage;\n}\n\n/**\n * Create an empty Ast.String node, adding a warning message from\n * the source file into the VFile.\n */\nexport function emptyStringWithWarningFactory(\n    warningMessage: string\n): (node: Ast.Node, info: VisitInfo, file?: VFile) => Ast.String {\n    return (node, info, file) => {\n        // add a warning message\n        if (file) {\n            const message = makeWarningMessage(\n                node,\n                warningMessage,\n                \"macro-subs\"\n            );\n            file.message(\n                message,\n                message.place,\n                `unified-latex-to-pretext:macro-subs`\n            );\n        }\n\n        return s(\"\");\n    };\n}\n","import { env, arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getNamedArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport {\n    anyEnvironment,\n    anyMacro,\n    match,\n} from \"@unified-latex/unified-latex-util-match\";\nimport { replaceNode } from \"@unified-latex/unified-latex-util-replace\";\nimport {\n    splitOnMacro,\n    unsplitOnMacro,\n} from \"@unified-latex/unified-latex-util-split\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { VFileMessage } from \"vfile-message\";\nimport { makeWarningMessage } from \"./utils\";\n\n/**\n * All the divisions, where each item is {division macro, mapped environment}.\n * Note that this is ordered from the \"largest\" division to the \"smallest\" division.\n */\nexport const divisions: { division: string; mappedEnviron: string }[] = [\n    { division: \"part\", mappedEnviron: \"_part\" },\n    { division: \"chapter\", mappedEnviron: \"_chapter\" },\n    { division: \"section\", mappedEnviron: \"_section\" },\n    { division: \"subsection\", mappedEnviron: \"_subsection\" },\n    { division: \"subsubsection\", mappedEnviron: \"_subsubsection\" },\n    { division: \"paragraph\", mappedEnviron: \"_paragraph\" },\n    { division: \"subparagraph\", mappedEnviron: \"_subparagraph\" },\n];\n\n// check if a macro is a division macro\nconst isDivisionMacro = match.createMacroMatcher(\n    divisions.map((x) => x.division)\n);\n\n// check if an environment is a newly created environment\nexport const isMappedEnviron = match.createEnvironmentMatcher(\n    divisions.map((x) => x.mappedEnviron)\n);\n\n/**\n * Breaks up division macros into environments. Returns an object of warning messages\n * for any groups that were removed.\n */\nexport function breakOnBoundaries(ast: Ast.Ast): { messages: VFileMessage[] } {\n    // messages for any groups removed\n    const messagesLst: { messages: VFileMessage[] } = { messages: [] };\n\n    replaceNode(ast, (node) => {\n        if (match.group(node)) {\n            // remove if it contains a division as an immediate child\n            if (\n                node.content.some((child) => {\n                    return anyMacro(child) && isDivisionMacro(child);\n                })\n            ) {\n                // add a warning message\n                messagesLst.messages.push(\n                    makeWarningMessage(\n                        node,\n                        \"Warning: hoisted out of a group, which might break the LaTeX code.\",\n                        \"break-on-boundaries\"\n                    )\n                );\n\n                return node.content;\n            }\n        }\n    });\n\n    visit(ast, (node, info) => {\n        // needs to be an environment, root, or group node\n        if (\n            !(\n                anyEnvironment(node) ||\n                node.type === \"root\" ||\n                match.group(node)\n            ) ||\n            // skip math mode\n            info.context.hasMathModeAncestor\n        ) {\n            return;\n        }\n        // if it's an environment, make sure it isn't a newly created one\n        else if (anyEnvironment(node) && isMappedEnviron(node)) {\n            return;\n        }\n\n        // now break up the divisions, starting at part\n        node.content = breakUp(node.content, 0);\n    });\n\n    replaceNode(ast, (node) => {\n        // remove all old division nodes\n        if (anyMacro(node) && isDivisionMacro(node)) {\n            return null;\n        }\n    });\n\n    return messagesLst;\n}\n\n/**\n * Recursively breaks up the AST at the division macros.\n */\nfunction breakUp(content: Ast.Node[], depth: number): Ast.Node[] {\n    // broke up all divisions\n    if (depth > 6) {\n        return content;\n    }\n\n    const splits = splitOnMacro(content, divisions[depth].division);\n\n    // go through each segment to recursively break\n    for (let i = 0; i < splits.segments.length; i++) {\n        splits.segments[i] = breakUp(splits.segments[i], depth + 1);\n    }\n\n    createEnvironments(splits, divisions[depth].mappedEnviron);\n\n    // rebuild this part of the AST\n    return unsplitOnMacro(splits);\n}\n\n/**\n * Create the new environments that replace the division macros.\n */\nfunction createEnvironments(\n    splits: { segments: Ast.Node[][]; macros: Ast.Macro[] },\n    newEnviron: string\n): void {\n    // loop through segments (skipping first segment)\n    for (let i = 1; i < splits.segments.length; i++) {\n        // get the title\n        const title = getNamedArgsContent(splits.macros[i - 1])[\"title\"];\n        const titleArg: Ast.Argument[] = [];\n\n        // create title argument\n        if (title) {\n            titleArg.push(arg(title, { braces: \"[]\" }));\n        }\n\n        // wrap segment with a new environment\n        splits.segments[i] = [env(newEnviron, splits.segments[i], titleArg)];\n    }\n}\n","import * as Xast from \"xast\";\nimport { x } from \"xastscript\";\nimport {\n    extractFromHtmlLike,\n    isHtmlLikeTag,\n} from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport {\n    divisions,\n    isMappedEnviron,\n} from \"../pre-conversion-subs/break-on-boundaries\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\n\nfunction formatNodeForError(node: Ast.Node | any): string {\n    try {\n        return printRaw(node);\n    } catch {}\n    return JSON.stringify(node);\n}\n\ntype XastNode = Xast.Element | Xast.Text | Xast.Comment;\n\n/**\n * Create a `toPretext` function that will log by making a call to `logger`.\n */\nexport function toPretextWithLoggerFactory(\n    logger: (message: string, node: any) => void\n) {\n    /**\n     * Convert Ast.Node to Xast nodes.\n     */\n    return function toPretext(\n        node: Ast.Node | Ast.Argument\n    ): XastNode | XastNode[] {\n        // Because `isHtmlLikeTag` is a type guard, if we use it directly on\n        // `node` here, then in the switch statement `node.type === \"macro\"` will be `never`.\n        // We rename the variable to avoid this issue.\n        const htmlNode = node;\n        if (isHtmlLikeTag(htmlNode)) {\n            const extracted = extractFromHtmlLike(htmlNode);\n            const attributes: Record<string, any> = extracted.attributes;\n            return x(\n                extracted.tag,\n                attributes,\n                extracted.content.flatMap(toPretext)\n            );\n        }\n\n        switch (node.type) {\n            case \"string\":\n                return {\n                    type: \"text\",\n                    value: node.content,\n                    position: node.position,\n                };\n            case \"comment\":\n                return {\n                    type: \"comment\",\n                    value: node.content,\n                    position: node.position,\n                };\n            case \"inlinemath\":\n                return x(\"m\", printRaw(node.content));\n            case \"mathenv\":\n            case \"displaymath\":\n                return x(\"me\", printRaw(node.content));\n            case \"verb\":\n            case \"verbatim\":\n                return x(\"pre\", node.content);\n            case \"whitespace\":\n                return { type: \"text\", value: \" \", position: node.position };\n            case \"parbreak\":\n                // warn first\n                logger(\n                    `There is no equivalent for parbreak, so it was replaced with an empty string.`,\n                    node\n                );\n\n                // return an empty string\n                return {\n                    type: \"text\",\n                    value: \"\",\n                    position: node.position,\n                };\n            case \"group\":\n                // Groups are just ignored.\n                return node.content.flatMap(toPretext);\n            case \"environment\":\n                // check if it's a new environment made to replace a division node\n                if (isMappedEnviron(node)) {\n                    // get the division macro associated with this node\n                    let divisionName = divisions.find(\n                        (x) => x.mappedEnviron === node.env\n                    )?.division;\n\n                    // for subparagraph, give a warning since pretext has no equivalent tag\n                    if (divisionName === \"subparagraph\") {\n                        logger(\n                            `Warning: There is no equivalent tag for \"subparagraph\", \"paragraphs\" was used as a replacement.`,\n                            node\n                        );\n                    }\n\n                    // paragraph and subparagraph become paragraphs\n                    if (\n                        divisionName === \"paragraph\" ||\n                        divisionName === \"subparagraph\"\n                    ) {\n                        divisionName = \"paragraphs\";\n                    }\n\n                    // create a title tag containing the division macro's title arg\n                    const title = getArgsContent(node)[0];\n\n                    if (!title) {\n                        logger(\n                            `Warning: No title was given, so an empty title tag was used.`,\n                            node\n                        );\n                    }\n\n                    const titleTag = x(\"title\", title?.flatMap(toPretext));\n\n                    if (divisionName) {\n                        return x(divisionName, [\n                            titleTag,\n                            ...node.content.flatMap(toPretext),\n                        ]);\n                    }\n                }\n\n                logger(\n                    `Unknown environment when converting to XML \\`${formatNodeForError(\n                        node.env\n                    )}\\``,\n                    node\n                );\n                return node.content.flatMap(toPretext); // just remove the environment\n            case \"macro\":\n                logger(\n                    `Unknown macro when converting to XML \\`${formatNodeForError(\n                        node\n                    )}\\``,\n                    node\n                );\n                return (node.args || []).map(toPretext).flat();\n            case \"argument\":\n                logger(\n                    `Unknown argument when converting to XML \\`${formatNodeForError(\n                        node\n                    )}\\``,\n                    node\n                );\n                return {\n                    type: \"text\",\n                    value: printRaw(node.content),\n                    position: node.position,\n                };\n            case \"root\":\n                return node.content.flatMap(toPretext);\n            default: {\n                const _exhaustiveCheck: never = node;\n                throw new Error(\n                    `Unknown node type; cannot convert to XAST ${JSON.stringify(\n                        node\n                    )}`\n                );\n            }\n        }\n    };\n}\n\n/**\n * Convert Ast.Node to Xast nodes.\n */\nexport const toPretext = toPretextWithLoggerFactory(console.warn);\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Takes an array of nodes and splits it into chunks that should be wrapped\n * in HTML `<p>...</p>` tags, vs. not. By default environments are not wrapped\n * unless they are specified, and macros are included in a par unless they are excluded.\n *\n */\nexport function splitForPars(\n    nodes: Ast.Node[],\n    options: {\n        macrosThatBreakPars: string[];\n        environmentsThatDontBreakPars: string[];\n    }\n): { content: Ast.Node[]; wrapInPar: boolean }[] {\n    const ret: { content: Ast.Node[]; wrapInPar: boolean }[] = [];\n    let currBody: Ast.Node[] = [];\n    trim(nodes);\n\n    const isParBreakingMacro = match.createMacroMatcher(\n        options.macrosThatBreakPars\n    );\n    const isEnvThatShouldNotBreakPar = match.createEnvironmentMatcher(\n        options.environmentsThatDontBreakPars\n    );\n\n    /**\n     * Push and clear the contents of `currBody` to the return array.\n     * If there are any contents, it should be wrapped in an array.\n     */\n    function pushBody() {\n        if (currBody.length > 0) {\n            trim(currBody);\n            ret.push({ content: currBody, wrapInPar: true });\n            currBody = [];\n        }\n    }\n\n    for (const node of nodes) {\n        if (isParBreakingMacro(node)) {\n            pushBody();\n            ret.push({ content: [node], wrapInPar: false });\n            continue;\n        }\n        if (match.anyEnvironment(node) && !isEnvThatShouldNotBreakPar(node)) {\n            pushBody();\n            ret.push({ content: [node], wrapInPar: false });\n            continue;\n        }\n        if (match.parbreak(node) || match.macro(node, \"par\")) {\n            pushBody();\n            continue;\n        }\n        currBody.push(node);\n    }\n    pushBody();\n\n    return ret;\n}\n","import { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { splitForPars } from \"./split-for-pars\";\n\n/**\n * Wrap paragraphs in `<p>...</p>` tags.\n *\n * Paragraphs are inserted at\n *   * parbreak tokens\n *   * macros listed in `macrosThatBreakPars`\n *   * environments not listed in `environmentsThatDontBreakPars`\n */\nexport function wrapPars(\n    nodes: Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    const {\n        macrosThatBreakPars = [\n            \"part\",\n            \"chapter\",\n            \"section\",\n            \"subsection\",\n            \"subsubsection\",\n            \"paragraph\",\n            \"subparagraph\",\n            \"vspace\",\n            \"smallskip\",\n            \"medskip\",\n            \"bigskip\",\n            \"hfill\",\n        ],\n        environmentsThatDontBreakPars = [],\n    } = options || {};\n\n    const parSplits = splitForPars(nodes, {\n        macrosThatBreakPars,\n        environmentsThatDontBreakPars,\n    });\n\n    return parSplits.flatMap((part) => {\n        if (part.wrapInPar) {\n            return htmlLike({ tag: \"p\", content: part.content });\n        } else {\n            return part.content;\n        }\n    });\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport {\n    parseTabularSpec,\n    TabularColumn,\n} from \"@unified-latex/unified-latex-ctan/package/tabularx\";\nimport { parseAlignEnvironment } from \"@unified-latex/unified-latex-util-align\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\ntype Attributes = Record<string, string | Record<string, string>>;\n\n/**\n * Convert env into a tabular in PreTeXt.\n */\nexport function createTableFromTabular(env: Ast.Environment) {\n    const tabularBody = parseAlignEnvironment(env.content);\n    const args = getArgsContent(env);\n    let columnSpecs: TabularColumn[] = [];\n    try {\n        columnSpecs = parseTabularSpec(args[1] || []);\n    } catch (e) {}\n\n    // for the tabular tag\n    const attributes: Attributes = {};\n\n    // we only need the col tags if one of the columns aren't left aligned/have a border\n    let notLeftAligned: boolean = false;\n\n    // stores which columns have borders to the right\n    // number is the column's index in columnSpecs\n    const columnRightBorder: Record<number, boolean> = {};\n\n    const tableBody = tabularBody.map((row) => {\n        const content = row.cells.map((cell, i) => {\n            const columnSpec = columnSpecs[i];\n\n            if (columnSpec) {\n                const { alignment } = columnSpec;\n\n                // this will need to be in the tabular tag\n                if (\n                    columnSpec.pre_dividers.some(\n                        (div) => div.type === \"vert_divider\"\n                    )\n                ) {\n                    attributes[\"left\"] = \"minor\";\n                }\n\n                // check if the column has a right border\n                if (\n                    columnSpec.post_dividers.some(\n                        (div) => div.type === \"vert_divider\"\n                    )\n                ) {\n                    columnRightBorder[i] = true;\n                }\n\n                // check if the default alignment isn't used\n                if (alignment.alignment !== \"left\") {\n                    notLeftAligned = true;\n                }\n            }\n\n            // trim whitespace off cell\n            trim(cell);\n\n            return htmlLike({\n                tag: \"cell\",\n                content: cell,\n            });\n        });\n        return htmlLike({ tag: \"row\", content });\n    });\n\n    // add col tags if needed\n    if (notLeftAligned || Object.values(columnRightBorder).some((b) => b)) {\n        // go backwards since adding col tags to the front of the tableBody list\n        // otherwise, col tags will be in the reversed order\n        for (let i = columnSpecs.length; i >= 0; i--) {\n            const columnSpec = columnSpecs[i];\n\n            if (!columnSpec) {\n                continue;\n            }\n\n            const colAttributes: Attributes = {};\n            const { alignment } = columnSpec;\n\n            // add h-align attribute if not default\n            if (alignment.alignment !== \"left\") {\n                colAttributes[\"halign\"] = alignment.alignment;\n            }\n\n            // if there is a right border add it\n            if (columnRightBorder[i] === true) {\n                colAttributes[\"right\"] = \"minor\";\n            }\n\n            tableBody.unshift(\n                htmlLike({ tag: \"col\", attributes: colAttributes })\n            );\n        }\n    }\n\n    return htmlLike({\n        tag: \"tabular\",\n        content: tableBody,\n        attributes: attributes,\n    });\n}\n","import { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    getArgsContent,\n    getNamedArgsContent,\n} from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { wrapPars } from \"../wrap-pars\";\nimport { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport { VFile } from \"unified-lint-rule/lib\";\nimport { makeWarningMessage } from \"./utils\";\nimport { createTableFromTabular } from \"./create-table-from-tabular\";\n\nconst ITEM_ARG_NAMES_REG = [\"label\"] as const;\nconst ITEM_ARG_NAMES_BEAMER = [null, \"label\", null] as const;\ntype ItemArgs = Record<\n    (typeof ITEM_ARG_NAMES_REG)[number],\n    Ast.Node[] | null\n> & {\n    body: Ast.Node[];\n};\n\n/**\n * Extract the arguments to an `\\item` macro.\n */\nfunction getItemArgs(node: Ast.Macro): ItemArgs {\n    if (!Array.isArray(node.args)) {\n        throw new Error(\n            `Cannot find \\\\item macros arguments; you must attach the \\\\item body to the macro before calling this function ${JSON.stringify(\n                node\n            )}`\n        );\n    }\n    // The \"body\" has been added as a last argument to the `\\item` node. We\n    // ignore this argument when comparing argument signatures.\n    const argNames =\n        node.args.length - 1 === ITEM_ARG_NAMES_BEAMER.length\n            ? ITEM_ARG_NAMES_BEAMER\n            : ITEM_ARG_NAMES_REG;\n    const ret = Object.assign(\n        { body: node.args[node.args.length - 1].content },\n        getNamedArgsContent(node, argNames)\n    );\n    return ret as ItemArgs;\n}\n\nfunction enumerateFactory(parentTag = \"ol\") {\n    return function enumerateToHtml(env: Ast.Environment) {\n        // The body of an enumerate has already been processed and all relevant parts have\n        // been attached to \\item macros as arguments.\n        const items = env.content.filter((node) => match.macro(node, \"item\"));\n\n        // Figure out if there any manually-specified item labels. If there are,\n        // we need to add a title tag\n        let isDescriptionList = false;\n\n        const content = items.flatMap((node) => {\n            if (!match.macro(node) || !node.args) {\n                return [];\n            }\n\n            // We test the open mark to see if an optional argument was actually supplied.\n            const namedArgs = getItemArgs(node);\n\n            // if there are custom markers, don't want the title tag to be wrapped in pars\n            // so we wrap the body first\n            namedArgs.body = wrapPars(namedArgs.body);\n\n            // check if a custom marker is used\n            if (namedArgs.label != null) {\n                isDescriptionList = true;\n\n                // add title tag containing custom marker\n                namedArgs.body.unshift(\n                    htmlLike({\n                        tag: \"title\",\n                        content: namedArgs.label,\n                    })\n                );\n            }\n\n            const body = namedArgs.body;\n\n            return htmlLike({\n                tag: \"li\",\n                content: body,\n            });\n        });\n\n        return htmlLike({\n            tag: isDescriptionList ? \"dl\" : parentTag,\n            content,\n        });\n    };\n}\n\n/**\n * Factory function that builds html-like macros wrapping the contents of an environment.\n * Statement tags are added around the contents of the environment if requested.\n */\nfunction envFactory(\n    tag: string,\n    requiresStatementTag: boolean = false,\n    warningMessage: string = \"\",\n    attributes?: Record<string, string>\n): (env: Ast.Environment, info: VisitInfo, file?: VFile) => Ast.Macro {\n    return (env, info, file) => {\n        // add a warning message to the file if needed\n        if (warningMessage && file) {\n            const message = makeWarningMessage(env, warningMessage, \"env-subs\");\n            file.message(message, message.place, message.source);\n        }\n\n        // Wrap content of the environment in paragraph tags\n        let content = wrapPars(env.content);\n\n        // Add a statement around the contents of the environment if requested.\n        if (requiresStatementTag) {\n            content = [\n                htmlLike({\n                    tag: \"statement\",\n                    content: content,\n                }),\n            ];\n        }\n\n        // Add a title tag if the environment has a title\n        const args = getArgsContent(env);\n        if (args[0]) {\n            content.unshift(\n                htmlLike({\n                    tag: \"title\",\n                    content: args[0] || [],\n                })\n            );\n        }\n\n        // Put it all together\n        return htmlLike({\n            tag: tag,\n            content: content,\n        });\n    };\n}\n\n/**\n * Remove the env environment by returning the content in env only.\n */\nfunction removeEnv(env: Ast.Environment, info: VisitInfo, file?: VFile) {\n    // add warning\n    file?.message(\n        makeWarningMessage(\n            env,\n            `Warning: There is no equivalent tag for \\\"${env.env}\\\", so the ${env.env} environment was removed.`,\n            \"environment-subs\"\n        )\n    );\n\n    return env.content;\n}\n\n/**\n * Rules for replacing a macro with an html-like macro\n * that will render has pretext when printed.\n */\nexport const environmentReplacements: Record<\n    string,\n    (\n        node: Ast.Environment,\n        info: VisitInfo,\n        file?: VFile\n    ) => Ast.Node | Ast.Node[]\n> = {\n    // TODO: add additional envs like theorem, etc.\n    enumerate: enumerateFactory(\"ol\"),\n    itemize: enumerateFactory(\"ul\"),\n    center: removeEnv,\n    tabular: createTableFromTabular,\n    quote: (env) => {\n        return htmlLike({\n            tag: \"blockquote\",\n            content: env.content,\n        });\n    },\n    ...genEnvironmentReplacements(),\n};\n\nfunction genEnvironmentReplacements() {\n    let reps: Record<\n        string,\n        (node: Ast.Environment, info: VisitInfo, file?: VFile) => Ast.Node\n    > = {};\n    // First, a long list of pretext environments and their aliases.\n    const envAliases: Record<\n        string,\n        { requiresStatment: boolean; aliases: string[] }\n    > = {\n        abstract: { requiresStatment: false, aliases: [\"abs\", \"abstr\"] },\n        acknowledgement: { requiresStatment: false, aliases: [\"ack\"] },\n        algorithm: { requiresStatment: true, aliases: [\"algo\", \"alg\"] },\n        assumption: { requiresStatment: true, aliases: [\"assu\", \"ass\"] },\n        axiom: { requiresStatment: true, aliases: [\"axm\"] },\n        claim: { requiresStatment: true, aliases: [\"cla\"] },\n        conjecture: {\n            requiresStatment: true,\n            aliases: [\"con\", \"conj\", \"conjec\"],\n        },\n        construction: { requiresStatment: false, aliases: [] },\n        convention: { requiresStatment: false, aliases: [\"conv\"] },\n        corollary: {\n            requiresStatment: true,\n            aliases: [\"cor\", \"corr\", \"coro\", \"corol\", \"corss\"],\n        },\n        definition: {\n            requiresStatment: true,\n            aliases: [\"def\", \"defn\", \"dfn\", \"defi\", \"defin\", \"de\"],\n        },\n        example: {\n            requiresStatment: true,\n            aliases: [\"exam\", \"exa\", \"eg\", \"exmp\", \"expl\", \"exm\"],\n        },\n        exercise: { requiresStatment: true, aliases: [\"exer\", \"exers\"] },\n        exploration: { requiresStatment: false, aliases: [] },\n        fact: { requiresStatment: true, aliases: [] },\n        heuristic: { requiresStatment: true, aliases: [] },\n        hypothesis: { requiresStatment: true, aliases: [\"hyp\"] },\n        identity: { requiresStatment: true, aliases: [\"idnty\"] },\n        insight: { requiresStatment: false, aliases: [] },\n        investigation: { requiresStatment: false, aliases: [] },\n        lemma: {\n            requiresStatment: true,\n            aliases: [\"lem\", \"lma\", \"lemm\", \"lm\"],\n        },\n        notation: {\n            requiresStatment: false,\n            aliases: [\"no\", \"nota\", \"ntn\", \"nt\", \"notn\", \"notat\"],\n        },\n        note: { requiresStatment: false, aliases: [\"notes\"] },\n        observation: { requiresStatment: false, aliases: [\"obs\"] },\n        principle: { requiresStatment: true, aliases: [] },\n        problem: { requiresStatment: true, aliases: [\"prob\", \"prb\"] },\n        project: { requiresStatment: false, aliases: [] },\n        proof: { requiresStatment: false, aliases: [\"pf\", \"prf\", \"demo\"] },\n        proposition: {\n            requiresStatment: true,\n            aliases: [\"prop\", \"pro\", \"prp\", \"props\"],\n        },\n        question: {\n            requiresStatment: true,\n            aliases: [\"qu\", \"ques\", \"quest\", \"qsn\"],\n        },\n        remark: {\n            requiresStatment: false,\n            aliases: [\"rem\", \"rmk\", \"rema\", \"bem\", \"subrem\"],\n        },\n        task: { requiresStatment: true, aliases: [] },\n        theorem: {\n            requiresStatment: true,\n            aliases: [\"thm\", \"theo\", \"theor\", \"thmss\", \"thrm\"],\n        },\n        warning: { requiresStatment: false, aliases: [\"warn\", \"wrn\"] },\n    };\n    // For each environment PreTeXt has, we create entries for `environmentReplacements` using all reasonable aliases\n    const exapandedEnvAliases = Object.entries(envAliases).flatMap(\n        ([env, spec]) => [\n            [env, envFactory(env, spec.requiresStatment)],\n            ...spec.aliases.map((name) => [\n                name,\n                envFactory(env, spec.requiresStatment),\n            ]),\n        ]\n    );\n    return Object.fromEntries(exapandedEnvAliases);\n}\n","import {\n    attachSystemeSettingsAsRenderInfo,\n    systemeContentsToArray,\n} from \"@unified-latex/unified-latex-ctan/package/systeme\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport KATEX_SUPPORT_LIST from \"../katex-support.json\";\n\nconst LEFT: Ast.Macro = { type: \"macro\", content: \"left\" };\nconst RIGHT: Ast.Macro = { type: \"macro\", content: \"right\" };\nconst DEFAULT_LEFT_DELIM: Ast.Macro = { type: \"macro\", content: \"{\" };\nconst DEFAULT_RIGHT_DELIM: Ast.String = { type: \"string\", content: \".\" };\n\nexport const katexSpecificMacroReplacements: Record<\n    string,\n    (node: Ast.Macro) => Ast.Node | Ast.Node[]\n> = {\n    systeme: (node) => {\n        try {\n            const args = getArgsContent(node);\n            const whitelistedVariables = (args[1] || undefined) as\n                | (Ast.String | Ast.Macro)[]\n                | undefined;\n            const equations = args[3] || [];\n            const ret = systemeContentsToArray(equations, {\n                properSpacing: false,\n                whitelistedVariables,\n            });\n\n            // If we have information about the sysdelims, then apply them\n            if (node?._renderInfo?.sysdelims) {\n                const [frontDelim, backDelim]: [Ast.Node[], Ast.Node[]] = node\n                    ._renderInfo?.sysdelims as any;\n\n                return [\n                    LEFT,\n                    ...(frontDelim || []),\n                    ret,\n                    RIGHT,\n                    ...(backDelim || []),\n                ];\n            }\n\n            return [LEFT, DEFAULT_LEFT_DELIM, ret, RIGHT, DEFAULT_RIGHT_DELIM];\n        } catch (e) {\n            return node;\n        }\n    },\n    sysdelim: () => [],\n};\n\nfunction wrapInDisplayMath(ast: Ast.Node | Ast.Node[]): Ast.Node {\n    const content = Array.isArray(ast) ? ast : [ast];\n\n    return { type: \"displaymath\", content };\n}\n\nexport const katexSpecificEnvironmentReplacements: Record<\n    string,\n    (node: Ast.Environment) => Ast.Node | Ast.Node[]\n> = {\n    // katex supports the align environments, but it will only render them\n    // if you are already in math mode. Warning: these will produce invalid latex!\n    align: wrapInDisplayMath,\n    \"align*\": wrapInDisplayMath,\n    alignat: wrapInDisplayMath,\n    \"alignat*\": wrapInDisplayMath,\n    equation: wrapInDisplayMath,\n    \"equation*\": wrapInDisplayMath,\n};\n\n/**\n * Attach `renderInfo` needed for converting some macros into their\n * katex equivalents.\n */\nexport function attachNeededRenderInfo(ast: Ast.Ast) {\n    attachSystemeSettingsAsRenderInfo(ast);\n}\n\nexport const KATEX_SUPPORT = {\n    macros: KATEX_SUPPORT_LIST[\"KATEX_MACROS\"],\n    environments: KATEX_SUPPORT_LIST[\"KATEX_ENVIRONMENTS\"],\n};\n","import { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport { VFile } from \"vfile\";\nimport { makeWarningMessage, emptyStringWithWarningFactory } from \"./utils\";\n\n/**\n * Factory function that generates html-like macros that wrap their contents.\n * warningMessage is a warning for any latex macros that don't have an equivalent\n * pretext tag.\n */\nfunction factory(\n    tag: string,\n    warningMessage: string = \"\",\n    attributes?: Record<string, string>\n): (macro: Ast.Macro, info: VisitInfo, file?: VFile) => Ast.Macro {\n    return (macro, info, file) => {\n        if (!macro.args) {\n            throw new Error(\n                `Found macro to replace but couldn't find content ${printRaw(\n                    macro\n                )}`\n            );\n        }\n\n        // add a warning message to the file if needed\n        if (warningMessage && file) {\n            const message = makeWarningMessage(\n                macro,\n                `Warning: There is no equivalent tag for \\\"${macro.content}\\\", \\\"${tag}\\\" was used as a replacement.`,\n                \"macro-subs\"\n            );\n            file.message(message, message.place, message.source);\n        }\n\n        // Assume the meaningful argument is the last argument. This\n        // ensures that we can convert for default packages as well as\n        // packages like beamer, which may add optional arguments.\n        const args = getArgsContent(macro);\n        const content = args[args.length - 1] || [];\n        return htmlLike({ tag, content, attributes });\n    };\n}\n\nfunction createHeading(tag: string, attrs = {}) {\n    return (macro: Ast.Macro) => {\n        const args = getArgsContent(macro);\n        const attributes: Record<string, string> = {};\n\n        if (attrs) {\n            Object.assign(attributes, attrs);\n        }\n\n        return htmlLike({\n            tag,\n            content: args[args.length - 1] || [],\n            attributes,\n        });\n    };\n}\n\nexport const macroReplacements: Record<\n    string,\n    (node: Ast.Macro, info: VisitInfo, file?: VFile) => Ast.Node\n> = {\n    emph: factory(\"em\"),\n    textrm: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textrm\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    textsf: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textsf\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    texttt: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textsf\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    textsl: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textsl\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    textit: factory(\"em\"),\n    textbf: factory(\"alert\"),\n    underline: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"underline\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    mbox: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"mbox\\\", an empty Ast.String was used as a replacement.`\n    ),\n    phantom: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"phantom\\\", an empty Ast.String was used as a replacement.`\n    ),\n    appendix: createHeading(\"appendix\"),\n    url: (node) => {\n        const args = getArgsContent(node);\n        const url = printRaw(args[0] || \"#\");\n        return htmlLike({\n            tag: \"url\",\n            attributes: {\n                href: url,\n            },\n            content: [{ type: \"string\", content: url }],\n        });\n    },\n    href: (node) => {\n        const args = getArgsContent(node);\n        const url = printRaw(args[1] || \"#\");\n        return htmlLike({\n            tag: \"url\",\n            attributes: {\n                href: url,\n            },\n            content: args[2] || [],\n        });\n    },\n    hyperref: (node) => {\n        const args = getArgsContent(node);\n        const url = \"#\" + printRaw(args[0] || \"\");\n        return htmlLike({\n            tag: \"url\",\n            attributes: {\n                href: url,\n            },\n            content: args[1] || [],\n        });\n    },\n    \"\\\\\": emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"\\\\\\\", an empty Ast.String was used as a replacement.`\n    ),\n    vspace: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"vspace\\\", an empty Ast.String was used as a replacement.`\n    ),\n    hspace: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"hspace\\\", an empty Ast.String was used as a replacement.`\n    ),\n    textcolor: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textcolor\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    textsize: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"textsize\\\", an empty Ast.String was used as a replacement.`\n    ),\n    makebox: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"makebox\\\", an empty Ast.String was used as a replacement.`\n    ),\n    noindent: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"noindent\\\", an empty Ast.String was used as a replacement.`\n    ),\n    includegraphics: (node) => {\n        const args = getArgsContent(node);\n        const source = printRaw(args[args.length - 1] || []);\n        return htmlLike({\n            tag: \"image\",\n            attributes: {\n                source,\n            },\n            content: [],\n        });\n    },\n};\n","import { arg, m } from \"@unified-latex/unified-latex-builder\";\nimport { colorToTextcolorMacro } from \"@unified-latex/unified-latex-ctan/package/xcolor\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Factory function that generates a macro with bound arguments.\n *\n * e.g.\n * ```\n * factory(\"foo\")(\"bar\") -> `\\foo{bar}`\n * ```\n *\n * ```\n * factory(\"foo\", \"baz\")(\"bar\") -> `\\foo{baz}{bar}`\n * ```\n */\nfunction factory(\n    macroName: string,\n    ...boundArgs: string[]\n): (content: Ast.Node[], originalCommand: Ast.Macro) => Ast.Macro {\n    return (content, originalCommand) => {\n        return m(macroName, boundArgs.map((a) => arg(a)).concat(arg(content)));\n    };\n}\n\nexport const streamingMacroReplacements = {\n    color: colorToTextcolorMacro,\n    bfseries: factory(\"textbf\"),\n    itshape: factory(\"textit\"),\n    rmfamily: factory(\"textrm\"),\n    scshape: factory(\"textsc\"),\n    sffamily: factory(\"textsf\"),\n    slshape: factory(\"textsl\"),\n    ttfamily: factory(\"texttt\"),\n    Huge: factory(\"textsize\", \"Huge\"),\n    huge: factory(\"textsize\", \"huge\"),\n    LARGE: factory(\"textsize\", \"LARGE\"),\n    Large: factory(\"textsize\", \"Large\"),\n    large: factory(\"textsize\", \"large\"),\n    normalsize: factory(\"textsize\", \"normalsize\"),\n    small: factory(\"textsize\", \"small\"),\n    footnotesize: factory(\"textsize\", \"footnotesize\"),\n    scriptsize: factory(\"textsize\", \"scriptsize\"),\n    tiny: factory(\"textsize\", \"tiny\"),\n};\n","import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { wrapPars } from \"./wrap-pars\";\nimport { isMappedEnviron } from \"./pre-conversion-subs/break-on-boundaries\";\ntype PluginOptions = {\n    macrosThatBreakPars?: string[];\n    environmentsThatDontBreakPars?: string[];\n} | void;\n\n/**\n * Unified plugin to wrap paragraphs in `\\html-tag:p{...}` macros.\n * Because `-` and `:` cannot occur in regular macros, there is no risk of\n * a conflict.\n */\nexport const unifiedLatexWrapPars: Plugin<PluginOptions[], Ast.Root, Ast.Root> =\n    function unifiedLatexWrapPars(options) {\n        const { macrosThatBreakPars, environmentsThatDontBreakPars } =\n            options || {};\n        return (tree) => {\n            // If \\begin{document}...\\end{document} is present, we only wrap pars inside of it.\n\n            let hasDocumentEnv = false;\n            visit(\n                tree,\n                (env) => {\n                    if (\n                        match.environment(env, \"document\") ||\n                        isMappedEnviron(env)\n                    ) {\n                        if (match.environment(env, \"document\")) {\n                            hasDocumentEnv = true;\n                        }\n\n                        // While we're here, we might as well wrap the pars!\n                        env.content = wrapPars(env.content, {\n                            macrosThatBreakPars,\n                            environmentsThatDontBreakPars,\n                        });\n                    }\n                },\n                { test: match.anyEnvironment }\n            );\n\n            if (!hasDocumentEnv) {\n                // If there is no \\begin{document}...\\end{document}, we wrap top-level pars only.\n                tree.content = wrapPars(tree.content, {\n                    macrosThatBreakPars,\n                    environmentsThatDontBreakPars,\n                });\n            }\n        };\n    };\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { anyMacro, match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { KATEX_SUPPORT } from \"./katex-subs\";\nimport { VFileMessage } from \"vfile-message\";\nimport { makeWarningMessage } from \"./utils\";\n\n/**\n * Return a list of macros used in ast that are unsupported by KaTeX\n */\nexport function reportMacrosUnsupportedByKatex(ast: Ast.Ast): {\n    messages: VFileMessage[];\n} {\n    const unsupported: { messages: VFileMessage[] } = { messages: [] };\n\n    // match a macro supported by Katex\n    const isSupported = match.createMacroMatcher(KATEX_SUPPORT.macros);\n\n    // visit all nodes\n    visit(ast, (node, info) => {\n        // macro in math mode\n        if (anyMacro(node) && info.context.hasMathModeAncestor) {\n            // check if not supported by katex\n            if (!isSupported(node)) {\n                // add a warning message\n                unsupported.messages.push(\n                    makeWarningMessage(\n                        node,\n                        `Warning: \\\"${\n                            (node as Ast.Macro).content\n                        }\\\" is unsupported by Katex.`,\n                        \"report-unsupported-macro-katex\"\n                    )\n                );\n            }\n        }\n    });\n\n    return unsupported;\n}\n","import * as Hast from \"hast\";\nimport { Plugin, unified } from \"unified\";\nimport { unifiedLatexLintNoTexFontShapingCommands } from \"@unified-latex/unified-latex-lint/rules/unified-latex-lint-no-tex-font-shaping-commands\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\nimport {\n    anyEnvironment,\n    anyMacro,\n    match,\n} from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport {\n    replaceNode,\n    unifiedLatexReplaceStreamingCommands,\n} from \"@unified-latex/unified-latex-util-replace\";\nimport { EXIT, SKIP, visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { environmentReplacements as _environmentReplacements } from \"./pre-conversion-subs/environment-subs\";\nimport {\n    attachNeededRenderInfo,\n    katexSpecificEnvironmentReplacements,\n    katexSpecificMacroReplacements,\n} from \"./pre-conversion-subs/katex-subs\";\nimport { macroReplacements as _macroReplacements } from \"./pre-conversion-subs/macro-subs\";\nimport { streamingMacroReplacements } from \"./pre-conversion-subs/streaming-command-subs\";\nimport { unifiedLatexWrapPars } from \"./unified-latex-wrap-pars\";\nimport {\n    breakOnBoundaries,\n    isMappedEnviron,\n} from \"./pre-conversion-subs/break-on-boundaries\";\nimport { reportMacrosUnsupportedByKatex } from \"./pre-conversion-subs/report-unsupported-macro-katex\";\nimport { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { s } from \"@unified-latex/unified-latex-builder\";\n\ntype EnvironmentReplacements = typeof _environmentReplacements;\ntype MacroReplacements = typeof _macroReplacements;\n\nexport type PluginOptions = {\n    /**\n     * Functions called to replace environments during processing. Key values should match environment names.\n     *  You probably want to use the function `htmlLike(...)` to return a node that gets converted to specific HTML.\n     */\n    environmentReplacements?: EnvironmentReplacements;\n    /**\n     * Functions called to replace macros during processing. Key values should match macro names.\n     * You probably want to use the function `htmlLike(...)` to return a node that gets converted to specific HTML.\n     */\n    macroReplacements?: MacroReplacements;\n\n    /**\n     * A boolean where if it's true then the output won't be wrapped in the <pretext><article> ... etc. tags.\n     * If it's false (default), a valid and complete PreTeXt document is returned.\n     */\n    producePretextFragment?: boolean;\n};\n\n/**\n * Unified plugin to convert a `unified-latex` AST into an html-like AST. This replaces nodes\n * with html-like macros `\\html-tag:p{...}`, etc. macros. It is a step along the way to converting to HTML.\n * **It is unlikely you want to use this plugin directly**.\n *\n * Note: this plugin only wraps paragraphs in `p` tags if there are multiple paragraphs. Otherwise it omits the <p> tags.\n */\nexport const unifiedLatexToPretextLike: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Hast.Root\n> = function unifiedLatexToHtmlLike(options) {\n    const macroReplacements = Object.assign(\n        {},\n        _macroReplacements,\n        options?.macroReplacements || {}\n    );\n    const environmentReplacements = Object.assign(\n        {},\n        _environmentReplacements,\n        options?.environmentReplacements || {}\n    );\n    const producePretextFragment = options?.producePretextFragment\n        ? options?.producePretextFragment\n        : false;\n\n    const isReplaceableMacro = match.createMacroMatcher(macroReplacements);\n    const isReplaceableEnvironment = match.createEnvironmentMatcher(\n        environmentReplacements\n    );\n    const isKatexMacro = match.createMacroMatcher(\n        katexSpecificMacroReplacements\n    );\n    const isKatexEnvironment = match.createEnvironmentMatcher(\n        katexSpecificEnvironmentReplacements\n    );\n\n    return (tree, file) => {\n        const originalTree = tree;\n        // NOTE: These operations need to be done in a particular order.\n\n        // We _could_ keep comments around in html, but that can complicate dealing with whitespace,\n        // so we remove them.\n        deleteComments(tree);\n        let processor = unified()\n            // Replace `\\bf` etc. with `\\bfseries`. Only the latter are auto-recognized streaming commands\n            .use(unifiedLatexLintNoTexFontShapingCommands, { fix: true })\n            .use(unifiedLatexReplaceStreamingCommands, {\n                replacers: streamingMacroReplacements,\n            });\n\n        // convert division macros into environments\n        const warningMessages = breakOnBoundaries(tree);\n\n        // add warning messages into the file one at a time\n        for (const warningMessage of warningMessages.messages) {\n            file.message(\n                warningMessage,\n                warningMessage.place,\n                \"unified-latex-to-pretext:break-on-boundaries\"\n            );\n        }\n\n        // Must be done *after* streaming commands are replaced.\n        // We only wrap PARs if we *need* to. That is, if the content contains multiple paragraphs\n        if (shouldBeWrappedInPars(tree)) {\n            processor = processor.use(unifiedLatexWrapPars);\n        }\n        tree = processor.runSync(tree, file);\n\n        // Replace text-mode environments and then macros. Environments *must* be processed first, since\n        // environments like tabular use `\\\\` as a newline indicator, but a `\\\\` macro gets replaced with\n        // an empty Ast.String during macro replacement.\n        replaceNode(tree, (node, info) => {\n            // Children of math-mode are rendered by KaTeX/MathJax and so we shouldn't touch them!\n            if (info.context.hasMathModeAncestor) {\n                return;\n            }\n            if (isReplaceableEnvironment(node)) {\n                return environmentReplacements[printRaw(node.env)](\n                    node,\n                    info,\n                    file\n                );\n            }\n        });\n\n        replaceNode(tree, (node, info) => {\n            // Children of math-mode are rendered by KaTeX/MathJax and so we shouldn't touch them!\n            if (info.context.hasMathModeAncestor) {\n                return;\n            }\n            if (isReplaceableMacro(node)) {\n                const replacement = macroReplacements[node.content](\n                    node,\n                    info,\n                    file\n                );\n                return replacement;\n            }\n        });\n\n        // before replacing math-mode macros, report any macros that can't be replaced\n        const unsupportedByKatex = reportMacrosUnsupportedByKatex(tree);\n\n        // add these warning messages into the file one at a time\n        for (const warningMessage of unsupportedByKatex.messages) {\n            file.message(\n                warningMessage,\n                warningMessage.place,\n                \"unified-latex-to-pretext:report-unsupported-macro-katex\"\n            );\n        }\n\n        // Replace math-mode macros for appropriate KaTeX rendering\n        attachNeededRenderInfo(tree);\n        replaceNode(tree, (node) => {\n            if (isKatexMacro(node)) {\n                return katexSpecificMacroReplacements[node.content](node);\n            }\n            if (isKatexEnvironment(node)) {\n                return katexSpecificEnvironmentReplacements[printRaw(node.env)](\n                    node\n                );\n            }\n        });\n\n        // Wrap in enough tags to ensure a valid pretext document\n        if (!producePretextFragment) {\n            // choose a book or article tag\n            createValidPretextDoc(tree);\n\n            // wrap around with pretext tag\n            tree.content = [\n                htmlLike({ tag: \"pretext\", content: tree.content }),\n            ];\n        }\n\n        // Make sure we are actually mutating the current tree.\n        originalTree.content = tree.content;\n    };\n};\n\n/**\n * Does the content contain multiple paragraphs? If so, it should be wrapped in `p` tags.\n */\nfunction shouldBeWrappedInPars(tree: Ast.Root): boolean {\n    let content = tree.content;\n    visit(\n        tree,\n        (env) => {\n            if (match.anyEnvironment(env)) {\n                content = env.content;\n                return EXIT;\n            }\n        },\n        { test: (node) => match.environment(node, \"document\") }\n    );\n\n    return containsPar(content);\n}\n\nfunction containsPar(content: Ast.Node[]): boolean {\n    return content.some((node) => {\n        if (isMappedEnviron(node)) {\n            return containsPar(node.content);\n        }\n\n        return match.parbreak(node) || match.macro(node, \"par\");\n    });\n}\n\n/**\n * Wrap the tree content in a book or article tag.\n */\nfunction createValidPretextDoc(tree: Ast.Root): void {\n    // this will be incomplete since the author info isn't pushed yet, which obtains documentclass, title, etc.\n    let isBook: boolean = false;\n\n    // look for a \\documentclass (this will need to change, as this info will be gotten earlier)\n    const docClass = findMacro(tree, \"documentclass\");\n\n    // check if there was a documentclass\n    if (docClass) {\n        const docClassArg = getArgsContent(docClass)[0];\n\n        // get the actual class\n        if (docClassArg) {\n            const docClassTitle = docClassArg[0] as Ast.String;\n\n            // memoirs will be books too\n            if (\n                docClassTitle.content == \"book\" ||\n                docClassTitle.content == \"memoir\"\n            ) {\n                isBook = true;\n            }\n        }\n    }\n\n    // if we still don't know if it's a book, look for _chapters environments (since breakonboundaries was called before)\n    if (!isBook) {\n        visit(tree, (node) => {\n            if (anyEnvironment(node) && node.env == \"_chapter\") {\n                isBook = true;\n                return EXIT;\n            }\n        });\n    }\n\n    // a book and article tag must have a title tag right after it\n    // extract the title first\n    const title = findMacro(tree, \"title\");\n\n    if (title) {\n        const titleArg = getArgsContent(title)[1];\n\n        // get the actual title\n        if (titleArg) {\n            const titleString = titleArg[0] as Ast.String;\n            tree.content.unshift(\n                htmlLike({ tag: \"title\", content: titleString })\n            );\n        }\n        // if no title name was given, make an empty tag\n        else {\n            tree.content.unshift(htmlLike({ tag: \"title\", content: s(\"\") }));\n        }\n    }\n    // if there is no title, add an empty title tag\n    else {\n        tree.content.unshift(htmlLike({ tag: \"title\", content: s(\"\") }));\n    }\n\n    // now create a book or article tag\n    if (isBook) {\n        tree.content = [htmlLike({ tag: \"book\", content: tree.content })];\n    } else {\n        tree.content = [htmlLike({ tag: \"article\", content: tree.content })];\n    }\n}\n\n// this will likely be removed\nfunction findMacro(tree: Ast.Root, content: string): Ast.Macro | null {\n    let macro: Ast.Macro | null = null;\n\n    // look for the macro\n    visit(tree, (node) => {\n        // skip visiting the children of environments\n        if (anyEnvironment(node)) {\n            return SKIP;\n        }\n        if (anyMacro(node) && node.content === content) {\n            macro = node;\n            return EXIT;\n        }\n    });\n\n    return macro;\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    expandMacrosExcludingDefinitions,\n    listNewcommands,\n} from \"@unified-latex/unified-latex-util-macros\";\nimport { attachMacroArgs } from \"@unified-latex/unified-latex-util-arguments\";\nimport { anyMacro } from \"@unified-latex/unified-latex-util-match\";\nimport { EXIT, visit } from \"@unified-latex/unified-latex-util-visit\";\n\ntype NewCommandSpec = ReturnType<typeof listNewcommands>[number];\n\n/**\n * Expands user-defined macros\n */\nexport function expandUserDefinedMacros(ast: Ast.Ast): void {\n    const newcommands = listNewcommands(ast);\n\n    // get a set of all macros to be expanded\n    const macrosToExpand = new Set(newcommands.map((command) => command.name));\n\n    const macroInfo = Object.fromEntries(\n        newcommands.map((m) => [m.name, { signature: m.signature }])\n    );\n\n    // recursively expand at most 100 times\n    for (let i = 0; i < 100; i++) {\n        // check if any macros still need expanding\n        if (!needToExpand(ast, macrosToExpand)) {\n            break;\n        }\n\n        // attach the arguments to each macro before processing it\n        attachMacroArgs(ast, macroInfo);\n        expandMacrosExcludingDefinitions(ast, newcommands);\n    }\n}\n\nfunction needToExpand(ast: Ast.Ast, macros: Set<string>): boolean {\n    let needExpand = false;\n\n    visit(ast, (node) => {\n        if (anyMacro(node) && macros.has(node.content)) {\n            needExpand = true;\n            EXIT;\n        }\n    });\n\n    return needExpand;\n}\n","import * as Xast from \"xast\";\nimport { x } from \"xastscript\";\nimport { Plugin, unified } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { TypeGuard } from \"@unified-latex/unified-latex-types\";\nimport { expandUnicodeLigatures } from \"@unified-latex/unified-latex-util-ligatures\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { EXIT, visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { toPretextWithLoggerFactory } from \"./pretext-subs/to-pretext\";\nimport {\n    unifiedLatexToPretextLike,\n    PluginOptions as HtmlLikePluginOptions,\n} from \"./unified-latex-plugin-to-pretext-like\";\nimport { expandUserDefinedMacros } from \"./pre-conversion-subs/expand-user-defined-macros\";\n\nexport type PluginOptions = HtmlLikePluginOptions & {\n    /**\n     * A boolean where if it's true then the output won't be wrapped in the <pretext><article> ... etc. tags.\n     * If it's false (default), a valid and complete PreTeXt document is returned.\n     */\n    producePretextFragment?: boolean;\n};\n\n/**\n * Unified plugin to convert a `unified-latex` AST into a `xast` AST representation of PreTeXt source.\n */\nexport const unifiedLatexToPretext: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Xast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    return (tree, file) => {\n        const producePretextFragment = options?.producePretextFragment\n            ? options?.producePretextFragment\n            : false;\n\n        // expand user defined macros\n        expandUserDefinedMacros(tree);\n\n        // If there is a \\begin{document}...\\end{document}, that's the only\n        // content we want to convert.\n        let content = tree.content;\n        visit(\n            tree,\n            (env) => {\n                content = env.content;\n                return EXIT;\n            },\n            {\n                test: ((node) =>\n                    match.environment(\n                        node,\n                        \"document\"\n                    )) as TypeGuard<Ast.Environment>,\n            }\n        );\n\n        // since we don't want to wrap content outside of \\begin{document}...\\end{document} with <pretext>...</pretext>\n        tree.content = content;\n\n        unified().use(unifiedLatexToPretextLike, options).run(tree, file);\n\n        // This should happen right before converting to PreTeXt because macros like `\\&` should\n        // be expanded via html rules first (and not turned into their corresponding ligature directly)\n        expandUnicodeLigatures(tree);\n\n        // update content\n        content = tree.content;\n\n        const toXast = toPretextWithLoggerFactory(file.message.bind(file));\n        let converted = toXast({ type: \"root\", content });\n        if (!Array.isArray(converted)) {\n            converted = [converted];\n        }\n        // Wrap everything in a Xast.Root node\n        let ret = x();\n        ret.children = converted;\n\n        // add boilerplate\n        if (!producePretextFragment) {\n            ret.children.unshift({\n                type: \"instruction\",\n                name: \"xml\",\n                value: \"version='1.0' encoding='utf-8'\",\n            });\n        }\n        return ret;\n    };\n};\n","import { toXml } from \"xast-util-to-xml\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { processLatexViaUnified } from \"@unified-latex/unified-latex\";\nimport {\n    unifiedLatexToPretext,\n    PluginOptions,\n} from \"./unified-latex-plugin-to-pretext\";\nimport { Plugin } from \"unified\";\nimport { Root } from \"xast\";\n\n/**\n * Unified plugin to convert a `XAST` AST to a string.\n */\nexport const xmlCompilePlugin: Plugin<void[], Root, string> = function () {\n    this.Compiler = toXml;\n};\n\nconst _processor = processLatexViaUnified()\n    .use(unifiedLatexToPretext)\n    .use(xmlCompilePlugin);\n\n/**\n * Convert the `unified-latex` AST `tree` into an HTML string. If you need\n * more precise control or further processing, consider using `unified`\n * directly with the `unifiedLatexToPretext` plugin.\n *\n * For example,\n * ```\n * unified()\n *      .use(unifiedLatexFromString)\n *      .use(unifiedLatexToPretext)\n *      .use(rehypeStringify)\n *      .processSync(\"\\\\LaTeX to convert\")\n * ```\n */\nexport function convertToPretext(\n    tree: Ast.Node | Ast.Node[],\n    options?: PluginOptions\n): string {\n    let processor = _processor;\n    if (!Array.isArray(tree) && tree.type !== \"root\") {\n        tree = { type: \"root\", content: [tree] };\n    }\n    if (Array.isArray(tree)) {\n        tree = { type: \"root\", content: tree };\n    }\n\n    if (options) {\n        processor = _processor.use(unifiedLatexToPretext, options);\n    }\n\n    const hast = processor.runSync(tree);\n    return processor.stringify(hast);\n}\n"],"names":["x","toPretext","env","factory","unifiedLatexWrapPars","macroReplacements","_macroReplacements","environmentReplacements","_environmentReplacements","m"],"mappings":"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"}