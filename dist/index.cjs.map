{"version":3,"file":"index.cjs","sources":["../../../node_modules/xastscript/lib/index.js","../../../node_modules/bail/index.js","../../../node_modules/is-buffer/index.js","../../../node_modules/extend/index.js","../node_modules/is-plain-obj/index.js","../../../node_modules/trough/lib/index.js","../node_modules/unified/node_modules/unist-util-stringify-position/lib/index.js","../node_modules/unified/node_modules/vfile-message/lib/index.js","../node_modules/unified/node_modules/vfile/lib/minpath.browser.js","../node_modules/unified/node_modules/vfile/lib/minproc.browser.js","../node_modules/unified/node_modules/vfile/lib/minurl.shared.js","../node_modules/unified/node_modules/vfile/lib/minurl.browser.js","../node_modules/unified/node_modules/vfile/lib/index.js","../node_modules/unified/lib/index.js","../../../node_modules/vfile-message/node_modules/unist-util-stringify-position/lib/index.js","../../../node_modules/vfile-message/lib/index.js","../libs/pre-conversion-subs/utils.ts","../libs/pre-conversion-subs/break-on-boundaries.ts","../libs/pretext-subs/to-pretext.ts","../libs/split-for-pars.ts","../libs/wrap-pars.ts","../libs/pre-conversion-subs/create-table-from-tabular.ts","../libs/pre-conversion-subs/environment-subs.ts","../libs/pre-conversion-subs/katex-subs.ts","../libs/pre-conversion-subs/macro-subs.ts","../libs/pre-conversion-subs/streaming-command-subs.ts","../libs/unified-latex-wrap-pars.ts","../libs/pre-conversion-subs/report-unsupported-macro-katex.ts","../libs/unified-latex-plugin-to-pretext-like.ts","../libs/pre-conversion-subs/expand-user-defined-macros.ts","../libs/unified-latex-plugin-to-pretext.ts","../../../node_modules/stringify-entities/lib/core.js","../../../node_modules/stringify-entities/lib/util/format-basic.js","../../../node_modules/stringify-entities/lib/index.js","../../../node_modules/xast-util-to-xml/lib/util-escape.js","../../../node_modules/xast-util-to-xml/lib/cdata.js","../../../node_modules/xast-util-to-xml/lib/comment.js","../../../node_modules/xast-util-to-xml/lib/name.js","../../../node_modules/ccount/index.js","../../../node_modules/xast-util-to-xml/lib/value.js","../../../node_modules/xast-util-to-xml/lib/doctype.js","../../../node_modules/xast-util-to-xml/lib/element.js","../../../node_modules/xast-util-to-xml/lib/instruction.js","../../../node_modules/xast-util-to-xml/lib/text.js","../../../node_modules/xast-util-to-xml/lib/raw.js","../../../node_modules/xast-util-to-xml/lib/one.js","../../../node_modules/xast-util-to-xml/lib/index.js","../libs/convert-to-pretext.ts"],"sourcesContent":["/**\n * @typedef {import('xast').Element} Element\n * @typedef {import('xast').Nodes} Nodes\n * @typedef {import('xast').Root} Root\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `x` call.\n *\n * @typedef {boolean | number | string | null | undefined} Value\n *   Attribute value\n *\n * @typedef {{[attribute: string]: Value}} Attributes\n *   Acceptable value for element properties.\n *\n * @typedef {boolean | number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n * @typedef {Nodes | PrimitiveChild | ArrayChild} Child\n *   Acceptable child value.\n */\n\n// Define JSX.\n\n/**\n * @typedef {import('./jsx-classic.js').Element} x.JSX.Element\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} x.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} x.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} x.JSX.ElementChildrenAttribute\n */\n\n/**\n * Create XML trees in xast.\n *\n * @param name\n *   Qualified name.\n *\n *   Case sensitive and can contain a namespace prefix (such as `rdf:RDF`).\n *   When string, an `Element` is built.\n *   When nullish, a `Root` is built instead.\n * @param attributes\n *   Attributes of the element or first child.\n * @param children\n *   Children of the node.\n * @returns\n *   `Element` or `Root`.\n */\nexport const x =\n  // Note: not yet possible to use the spread `...children` in JSDoc overloads.\n  /**\n   * @type {{\n   *   (): Root\n   *   (name: null | undefined, ...children: Array<Child>): Root\n   *   (name: string, attributes?: Attributes, ...children: Array<Child>): Element\n   *   (name: string, ...children: Array<Child>): Element\n   * }}\n   */\n  (\n    /**\n     * @param {string | null | undefined} [name]\n     * @param {Attributes | Child | null | undefined} [attributes]\n     * @param {Array<Child>} children\n     * @returns {Result}\n     */\n    function (name, attributes, ...children) {\n      let index = -1\n      /** @type {Result} */\n      let node\n\n      if (name === undefined || name === null) {\n        node = {type: 'root', children: []}\n        // @ts-expect-error: Root builder doesn‚Äôt accept attributes.\n        children.unshift(attributes)\n      } else if (typeof name === 'string') {\n        node = {type: 'element', name, attributes: {}, children: []}\n\n        if (isAttributes(attributes)) {\n          /** @type {string} */\n          let key\n\n          for (key in attributes) {\n            // Ignore nullish and NaN values.\n            if (\n              attributes[key] !== undefined &&\n              attributes[key] !== null &&\n              (typeof attributes[key] !== 'number' ||\n                !Number.isNaN(attributes[key]))\n            ) {\n              node.attributes[key] = String(attributes[key])\n            }\n          }\n        } else {\n          children.unshift(attributes)\n        }\n      } else {\n        throw new TypeError('Expected element name, got `' + name + '`')\n      }\n\n      // Handle children.\n      while (++index < children.length) {\n        addChild(node.children, children[index])\n      }\n\n      return node\n    }\n  )\n\n/**\n * Add children.\n *\n * @param {Array<Child>} nodes\n *   List of nodes.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new TypeError('Expected node, nodes, string, got `' + value + '`')\n  }\n}\n\n/**\n * Check if `value` is `Attributes`.\n *\n * @param {Attributes | Child} value\n *   Value.\n * @returns {value is Attributes}\n *   Whether `value` is `Attributes`.\n */\nfunction isAttributes(value) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  return true\n}\n","/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */\nexport function bail(error) {\n  if (error) {\n    throw error\n  }\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","// To do: remove `void`s\n// To do: remove `null` from output of our APIs, allow it as user APIs.\n\n/**\n * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback\n *   Callback.\n *\n * @typedef {(...input: Array<any>) => any} Middleware\n *   Ware.\n *\n * @typedef Pipeline\n *   Pipeline.\n * @property {Run} run\n *   Run the pipeline.\n * @property {Use} use\n *   Add middleware.\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n *\n *   Calls `done` on completion with either an error or the output of the\n *   last middleware.\n *\n *   > üëâ **Note**: as the length of input defines whether async functions get a\n *   > `next` function,\n *   > it‚Äôs recommended to keep `input` at one value normally.\n\n *\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n *   Pipeline.\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or we‚Äôre done.\n     *\n     * @param {Error | null | undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware` into a uniform interface.\n *\n * You can pass all input to the resulting function.\n * `callback` is then called with the output of `middleware`.\n *\n * If `middleware` accepts more arguments than the later given in input,\n * an extra `done` function is passed to it after that input,\n * which must be called by `middleware`.\n *\n * The first value in `input` is the main input value.\n * All other input values are the rest input values.\n * The values given to `callback` are the input values,\n * merged with every non-nullish output value.\n *\n * * if `middleware` throws an error,\n *   returns a promise that is rejected,\n *   or calls the given `done` function with an error,\n *   `callback` is called with that error\n * * if `middleware` returns a value or returns a promise that is resolved,\n *   that value is the main output value\n * * if `middleware` calls `done`,\n *   all non-nullish values except for the first one (the error) overwrite the\n *   output values\n *\n * @param {Middleware} middleware\n *   Function to wrap.\n * @param {Callback} callback\n *   Callback called with the output of `middleware`.\n * @returns {Run}\n *   Wrapped middleware.\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result && result.then && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   *\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\n/**\n * Message.\n */\nexport class VFileMessage extends Error {\n  /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   *\n   *   > üëâ **Note**: you should use markdown.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */\n  // To do: next major: expose `undefined` everywhere instead of `null`.\n  constructor(reason, place, origin) {\n    /** @type {[string | null, string | null]} */\n    const parts = [null, null]\n    /** @type {Position} */\n    let position = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: {line: null, column: null},\n      // @ts-expect-error: \"\n      end: {line: null, column: null}\n    }\n\n    super()\n\n    if (typeof place === 'string') {\n      origin = place\n      place = undefined\n    }\n\n    if (typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        parts[1] = origin\n      } else {\n        parts[0] = origin.slice(0, index)\n        parts[1] = origin.slice(index + 1)\n      }\n    }\n\n    if (place) {\n      // Node.\n      if ('type' in place || 'position' in place) {\n        if (place.position) {\n          // To do: next major: deep clone.\n          // @ts-expect-error: looks like a position.\n          position = place.position\n        }\n      }\n      // Position.\n      else if ('start' in place || 'end' in place) {\n        // @ts-expect-error: looks like a position.\n        // To do: next major: deep clone.\n        position = place\n      }\n      // Point.\n      else if ('line' in place || 'column' in place) {\n        // To do: next major: deep clone.\n        position.start = place\n      }\n    }\n\n    // Fields from `Error`.\n    /**\n     * Serialized positional info of error.\n     *\n     * On normal errors, this would be something like `ParseError`, buit in\n     * `VFile` messages we use this space to show where an error happened.\n     */\n    this.name = stringifyPosition(place) || '1:1'\n\n    /**\n     * Reason for message.\n     *\n     * @type {string}\n     */\n    this.message = typeof reason === 'object' ? reason.message : reason\n\n    /**\n     * Stack of message.\n     *\n     * This is used by normal errors to show where something happened in\n     * programming code, irrelevant for `VFile` messages,\n     *\n     * @type {string}\n     */\n    this.stack = ''\n\n    if (typeof reason === 'object' && reason.stack) {\n      this.stack = reason.stack\n    }\n\n    /**\n     * Reason for message.\n     *\n     * > üëâ **Note**: you should use markdown.\n     *\n     * @type {string}\n     */\n    this.reason = this.message\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * State of problem.\n     *\n     * * `true` ‚Äî marks associated file as no longer processable (error)\n     * * `false` ‚Äî necessitates a (potential) change (warning)\n     * * `null | undefined` ‚Äî for things that might not need changing (info)\n     *\n     * @type {boolean | null | undefined}\n     */\n    this.fatal\n\n    /**\n     * Starting line of error.\n     *\n     * @type {number | null}\n     */\n    this.line = position.start.line\n\n    /**\n     * Starting column of error.\n     *\n     * @type {number | null}\n     */\n    this.column = position.start.column\n\n    /**\n     * Full unist position.\n     *\n     * @type {Position | null}\n     */\n    this.position = position\n\n    /**\n     * Namespace of message (example: `'my-package'`).\n     *\n     * @type {string | null}\n     */\n    this.source = parts[0]\n\n    /**\n     * Category of message (example: `'my-rule'`).\n     *\n     * @type {string | null}\n     */\n    this.ruleId = parts[1]\n\n    /**\n     * Path of a file (used throughout the `VFile` ecosystem).\n     *\n     * @type {string | null}\n     */\n    this.file\n\n    // The following fields are ‚Äúwell known‚Äù.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /**\n     * Specify the source value that‚Äôs being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string | null}\n     */\n    this.actual\n\n    /**\n     * Suggest acceptable values that can be used instead of `actual`.\n     *\n     * @type {Array<string> | null}\n     */\n    this.expected\n\n    /**\n     * Link to docs for the message.\n     *\n     * > üëâ **Note**: this must be an absolute URL that can be passed as `x`\n     * > to `new URL(x)`.\n     *\n     * @type {string | null}\n     */\n    this.url\n\n    /**\n     * Long form description of the message (you should use markdown).\n     *\n     * @type {string | null}\n     */\n    this.note\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.fatal = null\nVFileMessage.prototype.column = null\nVFileMessage.prototype.line = null\nVFileMessage.prototype.source = null\nVFileMessage.prototype.ruleId = null\nVFileMessage.prototype.position = null\n","// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node‚Äôs internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * Get the basename from a path.\n *\n * @param {string} path\n *   File path.\n * @param {string | undefined} [ext]\n *   Extension to strip.\n * @returns {string}\n *   Stem or basename.\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * Get the dirname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * Get an extname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   Extname.\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * Join segments from a path.\n *\n * @param {Array<string>} segments\n *   Path segments.\n * @returns {string}\n *   File path.\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string | undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Normalize a basic file path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n *   File path.\n * @param {boolean} allowAboveRoot\n *   Whether `..` can move above root.\n * @returns {string}\n *   File path.\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number | undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * Make sure `path` is a string.\n *\n * @param {string} path\n *   File path.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n","// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don‚Äôt think one tiny line of code can be copyrighted. üòÖ\nexport const proc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n","/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * Check if `fileUrlOrPath` looks like a URL.\n *\n * @param {unknown} fileUrlOrPath\n *   File path or URL.\n * @returns {fileUrlOrPath is URL}\n *   Whether it‚Äôs a URL.\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nexport function isUrl(fileUrlOrPath) {\n  return (\n    fileUrlOrPath !== null &&\n    typeof fileUrlOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.origin\n  )\n}\n","/// <reference lib=\"dom\" />\n\nimport {isUrl} from './minurl.shared.js'\n\n// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>\n\n/**\n * @param {string | URL} path\n *   File URL.\n * @returns {string}\n *   File URL.\n */\nexport function urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isUrl(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * Get a path from a POSIX URL.\n *\n * @param {URL} url\n *   URL.\n * @returns {string}\n *   File path.\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.charCodeAt(index) === 37 /* `%` */ &&\n      pathname.charCodeAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.charCodeAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\nexport {isUrl} from './minurl.shared.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n */\n\n/**\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *\n *   This is a copy of the types from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Options | URL | Value | VFile} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n *   Set multiple values.\n * @property {Value | null | undefined} [value]\n *   Set `value`.\n * @property {string | null | undefined} [cwd]\n *   Set `cwd`.\n * @property {Array<string> | null | undefined} [history]\n *   Set `history`.\n * @property {URL | string | null | undefined} [path]\n *   Set `path`.\n * @property {string | null | undefined} [basename]\n *   Set `basename`.\n * @property {string | null | undefined} [stem]\n *   Set `stem`.\n * @property {string | null | undefined} [extname]\n *   Set `extname`.\n * @property {string | null | undefined} [dirname]\n *   Set `dirname`.\n * @property {Data | null | undefined} [data]\n *   Set `data`.\n *\n * @typedef Map\n *   Raw source map.\n *\n *   See:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n *   Which version of the source map spec this map is following.\n * @property {Array<string>} sources\n *   An array of URLs to the original source files.\n * @property {Array<string>} names\n *   An array of identifiers which can be referenced by individual mappings.\n * @property {string | undefined} [sourceRoot]\n *   The URL root from which all sources are relative.\n * @property {Array<string> | undefined} [sourcesContent]\n *   An array of contents of the original source files.\n * @property {string} mappings\n *   A string of base64 VLQs which contain the actual mappings.\n * @property {string} file\n *   The generated file this source map is associated with.\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration.\n *\n *   A bunch of keys that will be shallow copied over to the new file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n *   Configuration for reporters.\n */\n\n/**\n * @template {ReporterSettings} Settings\n *   Options type.\n * @callback Reporter\n *   Type for a reporter.\n * @param {Array<VFile>} files\n *   Files to report.\n * @param {Settings} options\n *   Configuration.\n * @returns {string}\n *   Report.\n */\n\nimport bufferLike from 'is-buffer'\nimport {VFileMessage} from 'vfile-message'\nimport {path} from './minpath.js'\nimport {proc} from './minproc.js'\nimport {urlToPath, isUrl} from './minurl.js'\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n *\n * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}\n */\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer` ‚Äî `{value: options}`\n   * *   `URL` ‚Äî `{path: options}`\n   * *   `VFile` ‚Äî shallow copies its data over to the new file\n   * *   `object` ‚Äî all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || buffer(value)) {\n      options = {value}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else {\n      options = value\n    }\n\n    /**\n     * Place to store custom information (default: `{}`).\n     *\n     * It‚Äôs OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of filepaths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n    this.cwd = proc.cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are ‚Äúwell-known‚Äù.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (\n        prop in options &&\n        options[prop] !== undefined &&\n        options[prop] !== null\n      ) {\n        // @ts-expect-error: TS doesn‚Äôt understand basic reality.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) {\n        // @ts-expect-error: fine to set other things.\n        this[prop] = options[prop]\n      }\n    }\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if there‚Äôs no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = path.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = path.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if there‚Äôs no `path` yet.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = path.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? path.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when it‚Äôs a `Buffer`\n   *   (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding || undefined)\n  }\n\n  /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(reason, place, origin) {\n    const message = new VFileMessage(reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * > üëâ **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {void}\n *   Nothing.\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(path.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n\n/**\n * Assert `value` is a buffer.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Buffer}\n *   Whether `value` is a Node.js buffer.\n */\nfunction buffer(value) {\n  return bufferLike(value)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\nimport {bail} from 'bail'\nimport isBuffer from 'is-buffer'\nimport extend from 'extend'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\n\n// Expose a frozen processor.\nexport const unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = trough()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` can‚Äôt be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes‚Äô prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Point | PointLike | Position | PositionLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef Options\n *   Configuration.\n * @property {Array<Node> | null | undefined} [ancestors]\n *   Stack of (inclusive) ancestor nodes surrounding the message (optional).\n * @property {Error | null | undefined} [cause]\n *   Original error cause of the message (optional).\n * @property {Point | Position | null | undefined} [place]\n *   Place of message (optional).\n * @property {string | null | undefined} [ruleId]\n *   Category of message (optional, example: `'my-rule'`).\n * @property {string | null | undefined} [source]\n *   Namespace of who sent the message (optional, example: `'my-package'`).\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\n/**\n * Message.\n */\nexport class VFileMessage extends Error {\n  /**\n   * Create a message for `reason`.\n   *\n   * > ü™¶ **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Options | null | undefined} [options]\n   * @returns\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */\n  // eslint-disable-next-line complexity\n  constructor(causeOrReason, optionsOrParentOrPlace, origin) {\n    super()\n\n    if (typeof optionsOrParentOrPlace === 'string') {\n      origin = optionsOrParentOrPlace\n      optionsOrParentOrPlace = undefined\n    }\n\n    /** @type {string} */\n    let reason = ''\n    /** @type {Options} */\n    let options = {}\n    let legacyCause = false\n\n    if (optionsOrParentOrPlace) {\n      // Point.\n      if (\n        'line' in optionsOrParentOrPlace &&\n        'column' in optionsOrParentOrPlace\n      ) {\n        options = {place: optionsOrParentOrPlace}\n      }\n      // Position.\n      else if (\n        'start' in optionsOrParentOrPlace &&\n        'end' in optionsOrParentOrPlace\n      ) {\n        options = {place: optionsOrParentOrPlace}\n      }\n      // Node.\n      else if ('type' in optionsOrParentOrPlace) {\n        options = {\n          ancestors: [optionsOrParentOrPlace],\n          place: optionsOrParentOrPlace.position\n        }\n      }\n      // Options.\n      else {\n        options = {...optionsOrParentOrPlace}\n      }\n    }\n\n    if (typeof causeOrReason === 'string') {\n      reason = causeOrReason\n    }\n    // Error.\n    else if (!options.cause && causeOrReason) {\n      legacyCause = true\n      reason = causeOrReason.message\n      options.cause = causeOrReason\n    }\n\n    if (!options.ruleId && !options.source && typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        options.ruleId = origin\n      } else {\n        options.source = origin.slice(0, index)\n        options.ruleId = origin.slice(index + 1)\n      }\n    }\n\n    if (!options.place && options.ancestors && options.ancestors) {\n      const parent = options.ancestors[options.ancestors.length - 1]\n\n      if (parent) {\n        options.place = parent.position\n      }\n    }\n\n    const start =\n      options.place && 'start' in options.place\n        ? options.place.start\n        : options.place\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Stack of ancestor nodes surrounding the message.\n     *\n     * @type {Array<Node> | undefined}\n     */\n    this.ancestors = options.ancestors || undefined\n\n    /**\n     * Original error cause of the message.\n     *\n     * @type {Error | undefined}\n     */\n    this.cause = options.cause || undefined\n\n    /**\n     * Starting column of message.\n     *\n     * @type {number | undefined}\n     */\n    this.column = start ? start.column : undefined\n\n    /**\n     * State of problem.\n     *\n     * * `true` ‚Äî error, file not usable\n     * * `false` ‚Äî warning, change may be needed\n     * * `undefined` ‚Äî change likely not needed\n     *\n     * @type {boolean | null | undefined}\n     */\n    this.fatal = undefined\n\n    /**\n     * Path of a file (used throughout the `VFile` ecosystem).\n     *\n     * @type {string | undefined}\n     */\n    this.file\n\n    // Field from `Error`.\n    /**\n     * Reason for message.\n     *\n     * @type {string}\n     */\n    this.message = reason\n\n    /**\n     * Starting line of error.\n     *\n     * @type {number | undefined}\n     */\n    this.line = start ? start.line : undefined\n\n    // Field from `Error`.\n    /**\n     * Serialized positional info of message.\n     *\n     * On normal errors, this would be something like `ParseError`, buit in\n     * `VFile` messages we use this space to show where an error happened.\n     */\n    this.name = stringifyPosition(options.place) || '1:1'\n\n    /**\n     * Place of message.\n     *\n     * @type {Point | Position | undefined}\n     */\n    this.place = options.place || undefined\n\n    /**\n     * Reason for message, should use markdown.\n     *\n     * @type {string}\n     */\n    this.reason = this.message\n\n    /**\n     * Category of message (example: `'my-rule'`).\n     *\n     * @type {string | undefined}\n     */\n    this.ruleId = options.ruleId || undefined\n\n    /**\n     * Namespace of message (example: `'my-package'`).\n     *\n     * @type {string | undefined}\n     */\n    this.source = options.source || undefined\n\n    // Field from `Error`.\n    /**\n     * Stack of message.\n     *\n     * This is used by normal errors to show where something happened in\n     * programming code, irrelevant for `VFile` messages,\n     *\n     * @type {string}\n     */\n    this.stack =\n      legacyCause && options.cause && typeof options.cause.stack === 'string'\n        ? options.cause.stack\n        : ''\n\n    // The following fields are ‚Äúwell known‚Äù.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /**\n     * Specify the source value that‚Äôs being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string | undefined}\n     */\n    this.actual\n\n    /**\n     * Suggest acceptable values that can be used instead of `actual`.\n     *\n     * @type {Array<string> | undefined}\n     */\n    this.expected\n\n    /**\n     * Long form description of the message (you should use markdown).\n     *\n     * @type {string | undefined}\n     */\n    this.note\n\n    /**\n     * Link to docs for the message.\n     *\n     * > üëâ **Note**: this must be an absolute URL that can be passed as `x`\n     * > to `new URL(x)`.\n     *\n     * @type {string | undefined}\n     */\n    this.url\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.column = undefined\nVFileMessage.prototype.line = undefined\nVFileMessage.prototype.ancestors = undefined\nVFileMessage.prototype.cause = undefined\nVFileMessage.prototype.fatal = undefined\nVFileMessage.prototype.place = undefined\nVFileMessage.prototype.ruleId = undefined\nVFileMessage.prototype.source = undefined\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport { VFile } from \"vfile\";\nimport { s } from \"@unified-latex/unified-latex-builder\";\nimport { VFileMessage } from \"vfile-message\";\n\n/**\n * Create a warning message about node from the given source file.\n */\nexport function makeWarningMessage(\n    node: Ast.Node,\n    message: string,\n    warningType: string\n): VFileMessage {\n    const newMessage = new VFileMessage(message, node);\n\n    newMessage.source = `unified-latex-to-pretext:${warningType}`;\n\n    return newMessage;\n}\n\n/**\n * Create an empty Ast.String node, adding a warning message from\n * the source file into the VFile.\n */\nexport function emptyStringWithWarningFactory(\n    warningMessage: string\n): (node: Ast.Node, info: VisitInfo, file?: VFile) => Ast.String {\n    return (node, info, file) => {\n        // add a warning message\n        if (file) {\n            const message = makeWarningMessage(\n                node,\n                warningMessage,\n                \"macro-subs\"\n            );\n            file.message(\n                message,\n                message.place,\n                `unified-latex-to-pretext:macro-subs`\n            );\n        }\n\n        return s(\"\");\n    };\n}\n","import { env, arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getNamedArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport {\n    anyEnvironment,\n    anyMacro,\n    match,\n} from \"@unified-latex/unified-latex-util-match\";\nimport { replaceNode } from \"@unified-latex/unified-latex-util-replace\";\nimport {\n    splitOnMacro,\n    unsplitOnMacro,\n} from \"@unified-latex/unified-latex-util-split\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { VFileMessage } from \"vfile-message\";\nimport { makeWarningMessage } from \"./utils\";\n\n/**\n * All the divisions, where each item is {division macro, mapped environment}.\n * Note that this is ordered from the \"largest\" division to the \"smallest\" division.\n */\nexport const divisions: { division: string; mappedEnviron: string }[] = [\n    { division: \"part\", mappedEnviron: \"_part\" },\n    { division: \"chapter\", mappedEnviron: \"_chapter\" },\n    { division: \"section\", mappedEnviron: \"_section\" },\n    { division: \"subsection\", mappedEnviron: \"_subsection\" },\n    { division: \"subsubsection\", mappedEnviron: \"_subsubsection\" },\n    { division: \"paragraph\", mappedEnviron: \"_paragraph\" },\n    { division: \"subparagraph\", mappedEnviron: \"_subparagraph\" },\n];\n\n// check if a macro is a division macro\nconst isDivisionMacro = match.createMacroMatcher(\n    divisions.map((x) => x.division)\n);\n\n// check if an environment is a newly created environment\nexport const isMappedEnviron = match.createEnvironmentMatcher(\n    divisions.map((x) => x.mappedEnviron)\n);\n\n/**\n * Breaks up division macros into environments. Returns an object of warning messages\n * for any groups that were removed.\n */\nexport function breakOnBoundaries(ast: Ast.Ast): { messages: VFileMessage[] } {\n    // messages for any groups removed\n    const messagesLst: { messages: VFileMessage[] } = { messages: [] };\n\n    replaceNode(ast, (node) => {\n        if (match.group(node)) {\n            // remove if it contains a division as an immediate child\n            if (\n                node.content.some((child) => {\n                    return anyMacro(child) && isDivisionMacro(child);\n                })\n            ) {\n                // add a warning message\n                messagesLst.messages.push(\n                    makeWarningMessage(\n                        node,\n                        \"Warning: hoisted out of a group, which might break the LaTeX code.\",\n                        \"break-on-boundaries\"\n                    )\n                );\n\n                return node.content;\n            }\n        }\n    });\n\n    visit(ast, (node, info) => {\n        // needs to be an environment, root, or group node\n        if (\n            !(\n                anyEnvironment(node) ||\n                node.type === \"root\" ||\n                match.group(node)\n            ) ||\n            // skip math mode\n            info.context.hasMathModeAncestor\n        ) {\n            return;\n        }\n        // if it's an environment, make sure it isn't a newly created one\n        else if (anyEnvironment(node) && isMappedEnviron(node)) {\n            return;\n        }\n\n        // now break up the divisions, starting at part\n        node.content = breakUp(node.content, 0);\n    });\n\n    replaceNode(ast, (node) => {\n        // remove all old division nodes\n        if (anyMacro(node) && isDivisionMacro(node)) {\n            return null;\n        }\n    });\n\n    return messagesLst;\n}\n\n/**\n * Recursively breaks up the AST at the division macros.\n */\nfunction breakUp(content: Ast.Node[], depth: number): Ast.Node[] {\n    // broke up all divisions\n    if (depth > 6) {\n        return content;\n    }\n\n    const splits = splitOnMacro(content, divisions[depth].division);\n\n    // go through each segment to recursively break\n    for (let i = 0; i < splits.segments.length; i++) {\n        splits.segments[i] = breakUp(splits.segments[i], depth + 1);\n    }\n\n    createEnvironments(splits, divisions[depth].mappedEnviron);\n\n    // rebuild this part of the AST\n    return unsplitOnMacro(splits);\n}\n\n/**\n * Create the new environments that replace the division macros.\n */\nfunction createEnvironments(\n    splits: { segments: Ast.Node[][]; macros: Ast.Macro[] },\n    newEnviron: string\n): void {\n    // loop through segments (skipping first segment)\n    for (let i = 1; i < splits.segments.length; i++) {\n        // get the title\n        const title = getNamedArgsContent(splits.macros[i - 1])[\"title\"];\n        const titleArg: Ast.Argument[] = [];\n\n        // create title argument\n        if (title) {\n            titleArg.push(arg(title, { braces: \"[]\" }));\n        }\n\n        // wrap segment with a new environment\n        splits.segments[i] = [env(newEnviron, splits.segments[i], titleArg)];\n    }\n}\n","import * as Xast from \"xast\";\nimport { x } from \"xastscript\";\nimport {\n    extractFromHtmlLike,\n    isHtmlLikeTag,\n} from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport {\n    divisions,\n    isMappedEnviron,\n} from \"../pre-conversion-subs/break-on-boundaries\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\n\nfunction formatNodeForError(node: Ast.Node | any): string {\n    try {\n        return printRaw(node);\n    } catch {}\n    return JSON.stringify(node);\n}\n\ntype XastNode = Xast.Element | Xast.Text | Xast.Comment;\n\n/**\n * Create a `toPretext` function that will log by making a call to `logger`.\n */\nexport function toPretextWithLoggerFactory(\n    logger: (message: string, node: any) => void\n) {\n    /**\n     * Convert Ast.Node to Xast nodes.\n     */\n    return function toPretext(\n        node: Ast.Node | Ast.Argument\n    ): XastNode | XastNode[] {\n        // Because `isHtmlLikeTag` is a type guard, if we use it directly on\n        // `node` here, then in the switch statement `node.type === \"macro\"` will be `never`.\n        // We rename the variable to avoid this issue.\n        const htmlNode = node;\n        if (isHtmlLikeTag(htmlNode)) {\n            const extracted = extractFromHtmlLike(htmlNode);\n            const attributes: Record<string, any> = extracted.attributes;\n            return x(\n                extracted.tag,\n                attributes,\n                extracted.content.flatMap(toPretext)\n            );\n        }\n\n        switch (node.type) {\n            case \"string\":\n                return {\n                    type: \"text\",\n                    value: node.content,\n                    position: node.position,\n                };\n            case \"comment\":\n                return {\n                    type: \"comment\",\n                    value: node.content,\n                    position: node.position,\n                };\n            case \"inlinemath\":\n                return x(\"m\", printRaw(node.content));\n            case \"mathenv\":\n            case \"displaymath\":\n                return x(\"me\", printRaw(node.content));\n            case \"verb\":\n            case \"verbatim\":\n                return x(\"pre\", node.content);\n            case \"whitespace\":\n                return { type: \"text\", value: \" \", position: node.position };\n            case \"parbreak\":\n                // warn first\n                logger(\n                    `There is no equivalent for parbreak, so it was replaced with an empty string.`,\n                    node\n                );\n\n                // return an empty string\n                return {\n                    type: \"text\",\n                    value: \"\",\n                    position: node.position,\n                };\n            case \"group\":\n                // Groups are just ignored.\n                return node.content.flatMap(toPretext);\n            case \"environment\":\n                // check if it's a new environment made to replace a division node\n                if (isMappedEnviron(node)) {\n                    // get the division macro associated with this node\n                    let divisionName = divisions.find(\n                        (x) => x.mappedEnviron === node.env\n                    )?.division;\n\n                    // for subparagraph, give a warning since pretext has no equivalent tag\n                    if (divisionName === \"subparagraph\") {\n                        logger(\n                            `Warning: There is no equivalent tag for \"subparagraph\", \"paragraphs\" was used as a replacement.`,\n                            node\n                        );\n                    }\n\n                    // paragraph and subparagraph become paragraphs\n                    if (\n                        divisionName === \"paragraph\" ||\n                        divisionName === \"subparagraph\"\n                    ) {\n                        divisionName = \"paragraphs\";\n                    }\n\n                    // create a title tag containing the division macro's title arg\n                    const title = getArgsContent(node)[0];\n\n                    if (!title) {\n                        logger(\n                            `Warning: No title was given, so an empty title tag was used.`,\n                            node\n                        );\n                    }\n\n                    const titleTag = x(\"title\", title?.flatMap(toPretext));\n\n                    if (divisionName) {\n                        return x(divisionName, [\n                            titleTag,\n                            ...node.content.flatMap(toPretext),\n                        ]);\n                    }\n                }\n\n                logger(\n                    `Unknown environment when converting to XML \\`${formatNodeForError(\n                        node.env\n                    )}\\``,\n                    node\n                );\n                return node.content.flatMap(toPretext); // just remove the environment\n            case \"macro\":\n                logger(\n                    `Unknown macro when converting to XML \\`${formatNodeForError(\n                        node\n                    )}\\``,\n                    node\n                );\n                return (node.args || []).map(toPretext).flat();\n            case \"argument\":\n                logger(\n                    `Unknown argument when converting to XML \\`${formatNodeForError(\n                        node\n                    )}\\``,\n                    node\n                );\n                return {\n                    type: \"text\",\n                    value: printRaw(node.content),\n                    position: node.position,\n                };\n            case \"root\":\n                return node.content.flatMap(toPretext);\n            default: {\n                const _exhaustiveCheck: never = node;\n                throw new Error(\n                    `Unknown node type; cannot convert to XAST ${JSON.stringify(\n                        node\n                    )}`\n                );\n            }\n        }\n    };\n}\n\n/**\n * Convert Ast.Node to Xast nodes.\n */\nexport const toPretext = toPretextWithLoggerFactory(console.warn);\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Takes an array of nodes and splits it into chunks that should be wrapped\n * in HTML `<p>...</p>` tags, vs. not. By default environments are not wrapped\n * unless they are specified, and macros are included in a par unless they are excluded.\n *\n */\nexport function splitForPars(\n    nodes: Ast.Node[],\n    options: {\n        macrosThatBreakPars: string[];\n        environmentsThatDontBreakPars: string[];\n    }\n): { content: Ast.Node[]; wrapInPar: boolean }[] {\n    const ret: { content: Ast.Node[]; wrapInPar: boolean }[] = [];\n    let currBody: Ast.Node[] = [];\n    trim(nodes);\n\n    const isParBreakingMacro = match.createMacroMatcher(\n        options.macrosThatBreakPars\n    );\n    const isEnvThatShouldNotBreakPar = match.createEnvironmentMatcher(\n        options.environmentsThatDontBreakPars\n    );\n\n    /**\n     * Push and clear the contents of `currBody` to the return array.\n     * If there are any contents, it should be wrapped in an array.\n     */\n    function pushBody() {\n        if (currBody.length > 0) {\n            trim(currBody);\n            ret.push({ content: currBody, wrapInPar: true });\n            currBody = [];\n        }\n    }\n\n    for (const node of nodes) {\n        if (isParBreakingMacro(node)) {\n            pushBody();\n            ret.push({ content: [node], wrapInPar: false });\n            continue;\n        }\n        if (match.anyEnvironment(node) && !isEnvThatShouldNotBreakPar(node)) {\n            pushBody();\n            ret.push({ content: [node], wrapInPar: false });\n            continue;\n        }\n        if (match.parbreak(node) || match.macro(node, \"par\")) {\n            pushBody();\n            continue;\n        }\n        currBody.push(node);\n    }\n    pushBody();\n\n    return ret;\n}\n","import { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { splitForPars } from \"./split-for-pars\";\n\n/**\n * Wrap paragraphs in `<p>...</p>` tags.\n *\n * Paragraphs are inserted at\n *   * parbreak tokens\n *   * macros listed in `macrosThatBreakPars`\n *   * environments not listed in `environmentsThatDontBreakPars`\n */\nexport function wrapPars(\n    nodes: Ast.Node[],\n    options?: {\n        macrosThatBreakPars?: string[];\n        environmentsThatDontBreakPars?: string[];\n    }\n): Ast.Node[] {\n    const {\n        macrosThatBreakPars = [\n            \"part\",\n            \"chapter\",\n            \"section\",\n            \"subsection\",\n            \"subsubsection\",\n            \"paragraph\",\n            \"subparagraph\",\n            \"vspace\",\n            \"smallskip\",\n            \"medskip\",\n            \"bigskip\",\n            \"hfill\",\n        ],\n        environmentsThatDontBreakPars = [],\n    } = options || {};\n\n    const parSplits = splitForPars(nodes, {\n        macrosThatBreakPars,\n        environmentsThatDontBreakPars,\n    });\n\n    return parSplits.flatMap((part) => {\n        if (part.wrapInPar) {\n            return htmlLike({ tag: \"p\", content: part.content });\n        } else {\n            return part.content;\n        }\n    });\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport {\n    parseTabularSpec,\n    TabularColumn,\n} from \"@unified-latex/unified-latex-ctan/package/tabularx\";\nimport { parseAlignEnvironment } from \"@unified-latex/unified-latex-util-align\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { trim } from \"@unified-latex/unified-latex-util-trim\";\n\ntype Attributes = Record<string, string | Record<string, string>>;\n\n/**\n * Convert env into a tabular in PreTeXt.\n */\nexport function createTableFromTabular(env: Ast.Environment) {\n    const tabularBody = parseAlignEnvironment(env.content);\n    const args = getArgsContent(env);\n    let columnSpecs: TabularColumn[] = [];\n    try {\n        columnSpecs = parseTabularSpec(args[1] || []);\n    } catch (e) {}\n\n    // for the tabular tag\n    const attributes: Attributes = {};\n\n    // we only need the col tags if one of the columns aren't left aligned/have a border\n    let notLeftAligned: boolean = false;\n\n    // stores which columns have borders to the right\n    // number is the column's index in columnSpecs\n    const columnRightBorder: Record<number, boolean> = {};\n\n    const tableBody = tabularBody.map((row) => {\n        const content = row.cells.map((cell, i) => {\n            const columnSpec = columnSpecs[i];\n\n            if (columnSpec) {\n                const { alignment } = columnSpec;\n\n                // this will need to be in the tabular tag\n                if (\n                    columnSpec.pre_dividers.some(\n                        (div) => div.type === \"vert_divider\"\n                    )\n                ) {\n                    attributes[\"left\"] = \"minor\";\n                }\n\n                // check if the column has a right border\n                if (\n                    columnSpec.post_dividers.some(\n                        (div) => div.type === \"vert_divider\"\n                    )\n                ) {\n                    columnRightBorder[i] = true;\n                }\n\n                // check if the default alignment isn't used\n                if (alignment.alignment !== \"left\") {\n                    notLeftAligned = true;\n                }\n            }\n\n            // trim whitespace off cell\n            trim(cell);\n\n            return htmlLike({\n                tag: \"cell\",\n                content: cell,\n            });\n        });\n        return htmlLike({ tag: \"row\", content });\n    });\n\n    // add col tags if needed\n    if (notLeftAligned || Object.values(columnRightBorder).some((b) => b)) {\n        // go backwards since adding col tags to the front of the tableBody list\n        // otherwise, col tags will be in the reversed order\n        for (let i = columnSpecs.length; i >= 0; i--) {\n            const columnSpec = columnSpecs[i];\n\n            if (!columnSpec) {\n                continue;\n            }\n\n            const colAttributes: Attributes = {};\n            const { alignment } = columnSpec;\n\n            // add h-align attribute if not default\n            if (alignment.alignment !== \"left\") {\n                colAttributes[\"halign\"] = alignment.alignment;\n            }\n\n            // if there is a right border add it\n            if (columnRightBorder[i] === true) {\n                colAttributes[\"right\"] = \"minor\";\n            }\n\n            tableBody.unshift(\n                htmlLike({ tag: \"col\", attributes: colAttributes })\n            );\n        }\n    }\n\n    return htmlLike({\n        tag: \"tabular\",\n        content: tableBody,\n        attributes: attributes,\n    });\n}\n","import { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    getArgsContent,\n    getNamedArgsContent,\n} from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { wrapPars } from \"../wrap-pars\";\nimport { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport { VFile } from \"unified-lint-rule/lib\";\nimport { makeWarningMessage } from \"./utils\";\nimport { createTableFromTabular } from \"./create-table-from-tabular\";\n\nconst ITEM_ARG_NAMES_REG = [\"label\"] as const;\nconst ITEM_ARG_NAMES_BEAMER = [null, \"label\", null] as const;\ntype ItemArgs = Record<\n    (typeof ITEM_ARG_NAMES_REG)[number],\n    Ast.Node[] | null\n> & {\n    body: Ast.Node[];\n};\n\n/**\n * Extract the arguments to an `\\item` macro.\n */\nfunction getItemArgs(node: Ast.Macro): ItemArgs {\n    if (!Array.isArray(node.args)) {\n        throw new Error(\n            `Cannot find \\\\item macros arguments; you must attach the \\\\item body to the macro before calling this function ${JSON.stringify(\n                node\n            )}`\n        );\n    }\n    // The \"body\" has been added as a last argument to the `\\item` node. We\n    // ignore this argument when comparing argument signatures.\n    const argNames =\n        node.args.length - 1 === ITEM_ARG_NAMES_BEAMER.length\n            ? ITEM_ARG_NAMES_BEAMER\n            : ITEM_ARG_NAMES_REG;\n    const ret = Object.assign(\n        { body: node.args[node.args.length - 1].content },\n        getNamedArgsContent(node, argNames)\n    );\n    return ret as ItemArgs;\n}\n\nfunction enumerateFactory(parentTag = \"ol\") {\n    return function enumerateToHtml(env: Ast.Environment) {\n        // The body of an enumerate has already been processed and all relevant parts have\n        // been attached to \\item macros as arguments.\n        const items = env.content.filter((node) => match.macro(node, \"item\"));\n\n        // Figure out if there any manually-specified item labels. If there are,\n        // we need to add a title tag\n        let isDescriptionList = false;\n\n        const content = items.flatMap((node) => {\n            if (!match.macro(node) || !node.args) {\n                return [];\n            }\n\n            // We test the open mark to see if an optional argument was actually supplied.\n            const namedArgs = getItemArgs(node);\n\n            // if there are custom markers, don't want the title tag to be wrapped in pars\n            // so we wrap the body first\n            namedArgs.body = wrapPars(namedArgs.body);\n\n            // check if a custom marker is used\n            if (namedArgs.label != null) {\n                isDescriptionList = true;\n\n                // add title tag containing custom marker\n                namedArgs.body.unshift(\n                    htmlLike({\n                        tag: \"title\",\n                        content: namedArgs.label,\n                    })\n                );\n            }\n\n            const body = namedArgs.body;\n\n            return htmlLike({\n                tag: \"li\",\n                content: body,\n            });\n        });\n\n        return htmlLike({\n            tag: isDescriptionList ? \"dl\" : parentTag,\n            content,\n        });\n    };\n}\n\n/**\n * Factory function that builds html-like macros wrapping the contents of an environment.\n * Statement tags are added around the contents of the environment if requested.\n */\nfunction envFactory(\n    tag: string,\n    requiresStatementTag: boolean = false,\n    warningMessage: string = \"\",\n    attributes?: Record<string, string>\n): (env: Ast.Environment, info: VisitInfo, file?: VFile) => Ast.Macro {\n    return (env, info, file) => {\n        // add a warning message to the file if needed\n        if (warningMessage && file) {\n            const message = makeWarningMessage(env, warningMessage, \"env-subs\");\n            file.message(message, message.place, message.source);\n        }\n\n        // Wrap content of the environment in paragraph tags\n        let content = wrapPars(env.content);\n\n        // Add a statement around the contents of the environment if requested.\n        if (requiresStatementTag) {\n            content = [\n                htmlLike({\n                    tag: \"statement\",\n                    content: content,\n                }),\n            ];\n        }\n\n        // Add a title tag if the environment has a title\n        const args = getArgsContent(env);\n        if (args[0]) {\n            content.unshift(\n                htmlLike({\n                    tag: \"title\",\n                    content: args[0] || [],\n                })\n            );\n        }\n\n        // Put it all together\n        return htmlLike({\n            tag: tag,\n            content: content,\n        });\n    };\n}\n\n/**\n * Remove the env environment by returning the content in env only.\n */\nfunction removeEnv(env: Ast.Environment, info: VisitInfo, file?: VFile) {\n    // add warning\n    file?.message(\n        makeWarningMessage(\n            env,\n            `Warning: There is no equivalent tag for \\\"${env.env}\\\", so the ${env.env} environment was removed.`,\n            \"environment-subs\"\n        )\n    );\n\n    return env.content;\n}\n\n/**\n * Rules for replacing a macro with an html-like macro\n * that will render has pretext when printed.\n */\nexport const environmentReplacements: Record<\n    string,\n    (\n        node: Ast.Environment,\n        info: VisitInfo,\n        file?: VFile\n    ) => Ast.Node | Ast.Node[]\n> = {\n    // TODO: add additional envs like theorem, etc.\n    enumerate: enumerateFactory(\"ol\"),\n    itemize: enumerateFactory(\"ul\"),\n    center: removeEnv,\n    tabular: createTableFromTabular,\n    quote: (env) => {\n        return htmlLike({\n            tag: \"blockquote\",\n            content: env.content,\n        });\n    },\n    ...genEnvironmentReplacements(),\n};\n\nfunction genEnvironmentReplacements() {\n    let reps: Record<\n        string,\n        (node: Ast.Environment, info: VisitInfo, file?: VFile) => Ast.Node\n    > = {};\n    // First, a long list of pretext environments and their aliases.\n    const envAliases: Record<\n        string,\n        { requiresStatment: boolean; aliases: string[] }\n    > = {\n        abstract: { requiresStatment: false, aliases: [\"abs\", \"abstr\"] },\n        acknowledgement: { requiresStatment: false, aliases: [\"ack\"] },\n        algorithm: { requiresStatment: true, aliases: [\"algo\", \"alg\"] },\n        assumption: { requiresStatment: true, aliases: [\"assu\", \"ass\"] },\n        axiom: { requiresStatment: true, aliases: [\"axm\"] },\n        claim: { requiresStatment: true, aliases: [\"cla\"] },\n        conjecture: {\n            requiresStatment: true,\n            aliases: [\"con\", \"conj\", \"conjec\"],\n        },\n        construction: { requiresStatment: false, aliases: [] },\n        convention: { requiresStatment: false, aliases: [\"conv\"] },\n        corollary: {\n            requiresStatment: true,\n            aliases: [\"cor\", \"corr\", \"coro\", \"corol\", \"corss\"],\n        },\n        definition: {\n            requiresStatment: true,\n            aliases: [\"def\", \"defn\", \"dfn\", \"defi\", \"defin\", \"de\"],\n        },\n        example: {\n            requiresStatment: true,\n            aliases: [\"exam\", \"exa\", \"eg\", \"exmp\", \"expl\", \"exm\"],\n        },\n        exercise: { requiresStatment: true, aliases: [\"exer\", \"exers\"] },\n        exploration: { requiresStatment: false, aliases: [] },\n        fact: { requiresStatment: true, aliases: [] },\n        heuristic: { requiresStatment: true, aliases: [] },\n        hypothesis: { requiresStatment: true, aliases: [\"hyp\"] },\n        identity: { requiresStatment: true, aliases: [\"idnty\"] },\n        insight: { requiresStatment: false, aliases: [] },\n        investigation: { requiresStatment: false, aliases: [] },\n        lemma: {\n            requiresStatment: true,\n            aliases: [\"lem\", \"lma\", \"lemm\", \"lm\"],\n        },\n        notation: {\n            requiresStatment: false,\n            aliases: [\"no\", \"nota\", \"ntn\", \"nt\", \"notn\", \"notat\"],\n        },\n        note: { requiresStatment: false, aliases: [\"notes\"] },\n        observation: { requiresStatment: false, aliases: [\"obs\"] },\n        principle: { requiresStatment: true, aliases: [] },\n        problem: { requiresStatment: true, aliases: [\"prob\", \"prb\"] },\n        project: { requiresStatment: false, aliases: [] },\n        proof: { requiresStatment: false, aliases: [\"pf\", \"prf\", \"demo\"] },\n        proposition: {\n            requiresStatment: true,\n            aliases: [\"prop\", \"pro\", \"prp\", \"props\"],\n        },\n        question: {\n            requiresStatment: true,\n            aliases: [\"qu\", \"ques\", \"quest\", \"qsn\"],\n        },\n        remark: {\n            requiresStatment: false,\n            aliases: [\"rem\", \"rmk\", \"rema\", \"bem\", \"subrem\"],\n        },\n        task: { requiresStatment: true, aliases: [] },\n        theorem: {\n            requiresStatment: true,\n            aliases: [\"thm\", \"theo\", \"theor\", \"thmss\", \"thrm\"],\n        },\n        warning: { requiresStatment: false, aliases: [\"warn\", \"wrn\"] },\n    };\n    // For each environment PreTeXt has, we create entries for `environmentReplacements` using all reasonable aliases\n    const exapandedEnvAliases = Object.entries(envAliases).flatMap(\n        ([env, spec]) => [\n            [env, envFactory(env, spec.requiresStatment)],\n            ...spec.aliases.map((name) => [\n                name,\n                envFactory(env, spec.requiresStatment),\n            ]),\n        ]\n    );\n    return Object.fromEntries(exapandedEnvAliases);\n}\n","import {\n    attachSystemeSettingsAsRenderInfo,\n    systemeContentsToArray,\n} from \"@unified-latex/unified-latex-ctan/package/systeme\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport KATEX_SUPPORT_LIST from \"../katex-support.json\";\n\nconst LEFT: Ast.Macro = { type: \"macro\", content: \"left\" };\nconst RIGHT: Ast.Macro = { type: \"macro\", content: \"right\" };\nconst DEFAULT_LEFT_DELIM: Ast.Macro = { type: \"macro\", content: \"{\" };\nconst DEFAULT_RIGHT_DELIM: Ast.String = { type: \"string\", content: \".\" };\n\nexport const katexSpecificMacroReplacements: Record<\n    string,\n    (node: Ast.Macro) => Ast.Node | Ast.Node[]\n> = {\n    systeme: (node) => {\n        try {\n            const args = getArgsContent(node);\n            const whitelistedVariables = (args[1] || undefined) as\n                | (Ast.String | Ast.Macro)[]\n                | undefined;\n            const equations = args[3] || [];\n            const ret = systemeContentsToArray(equations, {\n                properSpacing: false,\n                whitelistedVariables,\n            });\n\n            // If we have information about the sysdelims, then apply them\n            if (node?._renderInfo?.sysdelims) {\n                const [frontDelim, backDelim]: [Ast.Node[], Ast.Node[]] = node\n                    ._renderInfo?.sysdelims as any;\n\n                return [\n                    LEFT,\n                    ...(frontDelim || []),\n                    ret,\n                    RIGHT,\n                    ...(backDelim || []),\n                ];\n            }\n\n            return [LEFT, DEFAULT_LEFT_DELIM, ret, RIGHT, DEFAULT_RIGHT_DELIM];\n        } catch (e) {\n            return node;\n        }\n    },\n    sysdelim: () => [],\n};\n\nfunction wrapInDisplayMath(ast: Ast.Node | Ast.Node[]): Ast.Node {\n    const content = Array.isArray(ast) ? ast : [ast];\n\n    return { type: \"displaymath\", content };\n}\n\nexport const katexSpecificEnvironmentReplacements: Record<\n    string,\n    (node: Ast.Environment) => Ast.Node | Ast.Node[]\n> = {\n    // katex supports the align environments, but it will only render them\n    // if you are already in math mode. Warning: these will produce invalid latex!\n    align: wrapInDisplayMath,\n    \"align*\": wrapInDisplayMath,\n    alignat: wrapInDisplayMath,\n    \"alignat*\": wrapInDisplayMath,\n    equation: wrapInDisplayMath,\n    \"equation*\": wrapInDisplayMath,\n};\n\n/**\n * Attach `renderInfo` needed for converting some macros into their\n * katex equivalents.\n */\nexport function attachNeededRenderInfo(ast: Ast.Ast) {\n    attachSystemeSettingsAsRenderInfo(ast);\n}\n\nexport const KATEX_SUPPORT = {\n    macros: KATEX_SUPPORT_LIST[\"KATEX_MACROS\"],\n    environments: KATEX_SUPPORT_LIST[\"KATEX_ENVIRONMENTS\"],\n};\n","import { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { VisitInfo } from \"@unified-latex/unified-latex-util-visit\";\nimport { VFile } from \"vfile\";\nimport { makeWarningMessage, emptyStringWithWarningFactory } from \"./utils\";\n\n/**\n * Factory function that generates html-like macros that wrap their contents.\n * warningMessage is a warning for any latex macros that don't have an equivalent\n * pretext tag.\n */\nfunction factory(\n    tag: string,\n    warningMessage: string = \"\",\n    attributes?: Record<string, string>\n): (macro: Ast.Macro, info: VisitInfo, file?: VFile) => Ast.Macro {\n    return (macro, info, file) => {\n        if (!macro.args) {\n            throw new Error(\n                `Found macro to replace but couldn't find content ${printRaw(\n                    macro\n                )}`\n            );\n        }\n\n        // add a warning message to the file if needed\n        if (warningMessage && file) {\n            const message = makeWarningMessage(\n                macro,\n                `Warning: There is no equivalent tag for \\\"${macro.content}\\\", \\\"${tag}\\\" was used as a replacement.`,\n                \"macro-subs\"\n            );\n            file.message(message, message.place, message.source);\n        }\n\n        // Assume the meaningful argument is the last argument. This\n        // ensures that we can convert for default packages as well as\n        // packages like beamer, which may add optional arguments.\n        const args = getArgsContent(macro);\n        const content = args[args.length - 1] || [];\n        return htmlLike({ tag, content, attributes });\n    };\n}\n\nfunction createHeading(tag: string, attrs = {}) {\n    return (macro: Ast.Macro) => {\n        const args = getArgsContent(macro);\n        const attributes: Record<string, string> = {};\n\n        if (attrs) {\n            Object.assign(attributes, attrs);\n        }\n\n        return htmlLike({\n            tag,\n            content: args[args.length - 1] || [],\n            attributes,\n        });\n    };\n}\n\nexport const macroReplacements: Record<\n    string,\n    (node: Ast.Macro, info: VisitInfo, file?: VFile) => Ast.Node\n> = {\n    emph: factory(\"em\"),\n    textrm: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textrm\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    textsf: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textsf\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    texttt: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textsf\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    textsl: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textsl\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    textit: factory(\"em\"),\n    textbf: factory(\"alert\"),\n    underline: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"underline\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    mbox: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"mbox\\\", an empty Ast.String was used as a replacement.`\n    ),\n    phantom: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"phantom\\\", an empty Ast.String was used as a replacement.`\n    ),\n    appendix: createHeading(\"appendix\"),\n    url: (node) => {\n        const args = getArgsContent(node);\n        const url = printRaw(args[0] || \"#\");\n        return htmlLike({\n            tag: \"url\",\n            attributes: {\n                href: url,\n            },\n            content: [{ type: \"string\", content: url }],\n        });\n    },\n    href: (node) => {\n        const args = getArgsContent(node);\n        const url = printRaw(args[1] || \"#\");\n        return htmlLike({\n            tag: \"url\",\n            attributes: {\n                href: url,\n            },\n            content: args[2] || [],\n        });\n    },\n    hyperref: (node) => {\n        const args = getArgsContent(node);\n        const url = \"#\" + printRaw(args[0] || \"\");\n        return htmlLike({\n            tag: \"url\",\n            attributes: {\n                href: url,\n            },\n            content: args[1] || [],\n        });\n    },\n    \"\\\\\": emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"\\\\\\\", an empty Ast.String was used as a replacement.`\n    ),\n    vspace: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"vspace\\\", an empty Ast.String was used as a replacement.`\n    ),\n    hspace: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"hspace\\\", an empty Ast.String was used as a replacement.`\n    ),\n    textcolor: factory(\n        \"em\",\n        `Warning: There is no equivalent tag for \\\"textcolor\\\", \\\"em\\\" was used as a replacement.`\n    ),\n    textsize: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"textsize\\\", an empty Ast.String was used as a replacement.`\n    ),\n    makebox: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"makebox\\\", an empty Ast.String was used as a replacement.`\n    ),\n    noindent: emptyStringWithWarningFactory(\n        `Warning: There is no equivalent tag for \\\"noindent\\\", an empty Ast.String was used as a replacement.`\n    ),\n    includegraphics: (node) => {\n        const args = getArgsContent(node);\n        const source = printRaw(args[args.length - 1] || []);\n        return htmlLike({\n            tag: \"image\",\n            attributes: {\n                source,\n            },\n            content: [],\n        });\n    },\n};\n","import { arg, m } from \"@unified-latex/unified-latex-builder\";\nimport { colorToTextcolorMacro } from \"@unified-latex/unified-latex-ctan/package/xcolor\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\n\n/**\n * Factory function that generates a macro with bound arguments.\n *\n * e.g.\n * ```\n * factory(\"foo\")(\"bar\") -> `\\foo{bar}`\n * ```\n *\n * ```\n * factory(\"foo\", \"baz\")(\"bar\") -> `\\foo{baz}{bar}`\n * ```\n */\nfunction factory(\n    macroName: string,\n    ...boundArgs: string[]\n): (content: Ast.Node[], originalCommand: Ast.Macro) => Ast.Macro {\n    return (content, originalCommand) => {\n        return m(macroName, boundArgs.map((a) => arg(a)).concat(arg(content)));\n    };\n}\n\nexport const streamingMacroReplacements = {\n    color: colorToTextcolorMacro,\n    bfseries: factory(\"textbf\"),\n    itshape: factory(\"textit\"),\n    rmfamily: factory(\"textrm\"),\n    scshape: factory(\"textsc\"),\n    sffamily: factory(\"textsf\"),\n    slshape: factory(\"textsl\"),\n    ttfamily: factory(\"texttt\"),\n    Huge: factory(\"textsize\", \"Huge\"),\n    huge: factory(\"textsize\", \"huge\"),\n    LARGE: factory(\"textsize\", \"LARGE\"),\n    Large: factory(\"textsize\", \"Large\"),\n    large: factory(\"textsize\", \"large\"),\n    normalsize: factory(\"textsize\", \"normalsize\"),\n    small: factory(\"textsize\", \"small\"),\n    footnotesize: factory(\"textsize\", \"footnotesize\"),\n    scriptsize: factory(\"textsize\", \"scriptsize\"),\n    tiny: factory(\"textsize\", \"tiny\"),\n};\n","import { Plugin } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { wrapPars } from \"./wrap-pars\";\nimport { isMappedEnviron } from \"./pre-conversion-subs/break-on-boundaries\";\ntype PluginOptions = {\n    macrosThatBreakPars?: string[];\n    environmentsThatDontBreakPars?: string[];\n} | void;\n\n/**\n * Unified plugin to wrap paragraphs in `\\html-tag:p{...}` macros.\n * Because `-` and `:` cannot occur in regular macros, there is no risk of\n * a conflict.\n */\nexport const unifiedLatexWrapPars: Plugin<PluginOptions[], Ast.Root, Ast.Root> =\n    function unifiedLatexWrapPars(options) {\n        const { macrosThatBreakPars, environmentsThatDontBreakPars } =\n            options || {};\n        return (tree) => {\n            // If \\begin{document}...\\end{document} is present, we only wrap pars inside of it.\n\n            let hasDocumentEnv = false;\n            visit(\n                tree,\n                (env) => {\n                    if (\n                        match.environment(env, \"document\") ||\n                        isMappedEnviron(env)\n                    ) {\n                        if (match.environment(env, \"document\")) {\n                            hasDocumentEnv = true;\n                        }\n\n                        // While we're here, we might as well wrap the pars!\n                        env.content = wrapPars(env.content, {\n                            macrosThatBreakPars,\n                            environmentsThatDontBreakPars,\n                        });\n                    }\n                },\n                { test: match.anyEnvironment }\n            );\n\n            if (!hasDocumentEnv) {\n                // If there is no \\begin{document}...\\end{document}, we wrap top-level pars only.\n                tree.content = wrapPars(tree.content, {\n                    macrosThatBreakPars,\n                    environmentsThatDontBreakPars,\n                });\n            }\n        };\n    };\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { anyMacro, match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { KATEX_SUPPORT } from \"./katex-subs\";\nimport { VFileMessage } from \"vfile-message\";\nimport { makeWarningMessage } from \"./utils\";\n\n/**\n * Return a list of macros used in ast that are unsupported by KaTeX\n */\nexport function reportMacrosUnsupportedByKatex(ast: Ast.Ast): {\n    messages: VFileMessage[];\n} {\n    const unsupported: { messages: VFileMessage[] } = { messages: [] };\n\n    // match a macro supported by Katex\n    const isSupported = match.createMacroMatcher(KATEX_SUPPORT.macros);\n\n    // visit all nodes\n    visit(ast, (node, info) => {\n        // macro in math mode\n        if (anyMacro(node) && info.context.hasMathModeAncestor) {\n            // check if not supported by katex\n            if (!isSupported(node)) {\n                // add a warning message\n                unsupported.messages.push(\n                    makeWarningMessage(\n                        node,\n                        `Warning: \\\"${\n                            (node as Ast.Macro).content\n                        }\\\" is unsupported by Katex.`,\n                        \"report-unsupported-macro-katex\"\n                    )\n                );\n            }\n        }\n    });\n\n    return unsupported;\n}\n","import * as Hast from \"hast\";\nimport { Plugin, unified } from \"unified\";\nimport { unifiedLatexLintNoTexFontShapingCommands } from \"@unified-latex/unified-latex-lint/rules/unified-latex-lint-no-tex-font-shaping-commands\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { deleteComments } from \"@unified-latex/unified-latex-util-comments\";\nimport {\n    anyEnvironment,\n    anyMacro,\n    match,\n} from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport {\n    replaceNode,\n    unifiedLatexReplaceStreamingCommands,\n} from \"@unified-latex/unified-latex-util-replace\";\nimport { EXIT, SKIP, visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { environmentReplacements as _environmentReplacements } from \"./pre-conversion-subs/environment-subs\";\nimport {\n    attachNeededRenderInfo,\n    katexSpecificEnvironmentReplacements,\n    katexSpecificMacroReplacements,\n} from \"./pre-conversion-subs/katex-subs\";\nimport { macroReplacements as _macroReplacements } from \"./pre-conversion-subs/macro-subs\";\nimport { streamingMacroReplacements } from \"./pre-conversion-subs/streaming-command-subs\";\nimport { unifiedLatexWrapPars } from \"./unified-latex-wrap-pars\";\nimport {\n    breakOnBoundaries,\n    isMappedEnviron,\n} from \"./pre-conversion-subs/break-on-boundaries\";\nimport { reportMacrosUnsupportedByKatex } from \"./pre-conversion-subs/report-unsupported-macro-katex\";\nimport { htmlLike } from \"@unified-latex/unified-latex-util-html-like\";\nimport { getArgsContent } from \"@unified-latex/unified-latex-util-arguments\";\nimport { s } from \"@unified-latex/unified-latex-builder\";\n\ntype EnvironmentReplacements = typeof _environmentReplacements;\ntype MacroReplacements = typeof _macroReplacements;\n\nexport type PluginOptions = {\n    /**\n     * Functions called to replace environments during processing. Key values should match environment names.\n     *  You probably want to use the function `htmlLike(...)` to return a node that gets converted to specific HTML.\n     */\n    environmentReplacements?: EnvironmentReplacements;\n    /**\n     * Functions called to replace macros during processing. Key values should match macro names.\n     * You probably want to use the function `htmlLike(...)` to return a node that gets converted to specific HTML.\n     */\n    macroReplacements?: MacroReplacements;\n\n    /**\n     * A boolean where if it's true then the output won't be wrapped in the <pretext><article> ... etc. tags.\n     * If it's false (default), a valid and complete PreTeXt document is returned.\n     */\n    producePretextFragment?: boolean;\n};\n\n/**\n * Unified plugin to convert a `unified-latex` AST into an html-like AST. This replaces nodes\n * with html-like macros `\\html-tag:p{...}`, etc. macros. It is a step along the way to converting to HTML.\n * **It is unlikely you want to use this plugin directly**.\n *\n * Note: this plugin only wraps paragraphs in `p` tags if there are multiple paragraphs. Otherwise it omits the <p> tags.\n */\nexport const unifiedLatexToPretextLike: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Hast.Root\n> = function unifiedLatexToHtmlLike(options) {\n    const macroReplacements = Object.assign(\n        {},\n        _macroReplacements,\n        options?.macroReplacements || {}\n    );\n    const environmentReplacements = Object.assign(\n        {},\n        _environmentReplacements,\n        options?.environmentReplacements || {}\n    );\n    const producePretextFragment = options?.producePretextFragment\n        ? options?.producePretextFragment\n        : false;\n\n    const isReplaceableMacro = match.createMacroMatcher(macroReplacements);\n    const isReplaceableEnvironment = match.createEnvironmentMatcher(\n        environmentReplacements\n    );\n    const isKatexMacro = match.createMacroMatcher(\n        katexSpecificMacroReplacements\n    );\n    const isKatexEnvironment = match.createEnvironmentMatcher(\n        katexSpecificEnvironmentReplacements\n    );\n\n    return (tree, file) => {\n        const originalTree = tree;\n        // NOTE: These operations need to be done in a particular order.\n\n        // We _could_ keep comments around in html, but that can complicate dealing with whitespace,\n        // so we remove them.\n        deleteComments(tree);\n        let processor = unified()\n            // Replace `\\bf` etc. with `\\bfseries`. Only the latter are auto-recognized streaming commands\n            .use(unifiedLatexLintNoTexFontShapingCommands, { fix: true })\n            .use(unifiedLatexReplaceStreamingCommands, {\n                replacers: streamingMacroReplacements,\n            });\n\n        // convert division macros into environments\n        const warningMessages = breakOnBoundaries(tree);\n\n        // add warning messages into the file one at a time\n        for (const warningMessage of warningMessages.messages) {\n            file.message(\n                warningMessage,\n                warningMessage.place,\n                \"unified-latex-to-pretext:break-on-boundaries\"\n            );\n        }\n\n        // Must be done *after* streaming commands are replaced.\n        // We only wrap PARs if we *need* to. That is, if the content contains multiple paragraphs\n        if (shouldBeWrappedInPars(tree)) {\n            processor = processor.use(unifiedLatexWrapPars);\n        }\n        tree = processor.runSync(tree, file);\n\n        // Replace text-mode environments and then macros. Environments *must* be processed first, since\n        // environments like tabular use `\\\\` as a newline indicator, but a `\\\\` macro gets replaced with\n        // an empty Ast.String during macro replacement.\n        replaceNode(tree, (node, info) => {\n            // Children of math-mode are rendered by KaTeX/MathJax and so we shouldn't touch them!\n            if (info.context.hasMathModeAncestor) {\n                return;\n            }\n            if (isReplaceableEnvironment(node)) {\n                return environmentReplacements[printRaw(node.env)](\n                    node,\n                    info,\n                    file\n                );\n            }\n        });\n\n        replaceNode(tree, (node, info) => {\n            // Children of math-mode are rendered by KaTeX/MathJax and so we shouldn't touch them!\n            if (info.context.hasMathModeAncestor) {\n                return;\n            }\n            if (isReplaceableMacro(node)) {\n                const replacement = macroReplacements[node.content](\n                    node,\n                    info,\n                    file\n                );\n                return replacement;\n            }\n        });\n\n        // before replacing math-mode macros, report any macros that can't be replaced\n        const unsupportedByKatex = reportMacrosUnsupportedByKatex(tree);\n\n        // add these warning messages into the file one at a time\n        for (const warningMessage of unsupportedByKatex.messages) {\n            file.message(\n                warningMessage,\n                warningMessage.place,\n                \"unified-latex-to-pretext:report-unsupported-macro-katex\"\n            );\n        }\n\n        // Replace math-mode macros for appropriate KaTeX rendering\n        attachNeededRenderInfo(tree);\n        replaceNode(tree, (node) => {\n            if (isKatexMacro(node)) {\n                return katexSpecificMacroReplacements[node.content](node);\n            }\n            if (isKatexEnvironment(node)) {\n                return katexSpecificEnvironmentReplacements[printRaw(node.env)](\n                    node\n                );\n            }\n        });\n\n        // Wrap in enough tags to ensure a valid pretext document\n        if (!producePretextFragment) {\n            // choose a book or article tag\n            createValidPretextDoc(tree);\n\n            // wrap around with pretext tag\n            tree.content = [\n                htmlLike({ tag: \"pretext\", content: tree.content }),\n            ];\n        }\n\n        // Make sure we are actually mutating the current tree.\n        originalTree.content = tree.content;\n    };\n};\n\n/**\n * Does the content contain multiple paragraphs? If so, it should be wrapped in `p` tags.\n */\nfunction shouldBeWrappedInPars(tree: Ast.Root): boolean {\n    let content = tree.content;\n    visit(\n        tree,\n        (env) => {\n            if (match.anyEnvironment(env)) {\n                content = env.content;\n                return EXIT;\n            }\n        },\n        { test: (node) => match.environment(node, \"document\") }\n    );\n\n    return containsPar(content);\n}\n\nfunction containsPar(content: Ast.Node[]): boolean {\n    return content.some((node) => {\n        if (isMappedEnviron(node)) {\n            return containsPar(node.content);\n        }\n\n        return match.parbreak(node) || match.macro(node, \"par\");\n    });\n}\n\n/**\n * Wrap the tree content in a book or article tag.\n */\nfunction createValidPretextDoc(tree: Ast.Root): void {\n    // this will be incomplete since the author info isn't pushed yet, which obtains documentclass, title, etc.\n    let isBook: boolean = false;\n\n    // look for a \\documentclass (this will need to change, as this info will be gotten earlier)\n    const docClass = findMacro(tree, \"documentclass\");\n\n    // check if there was a documentclass\n    if (docClass) {\n        const docClassArg = getArgsContent(docClass)[0];\n\n        // get the actual class\n        if (docClassArg) {\n            const docClassTitle = docClassArg[0] as Ast.String;\n\n            // memoirs will be books too\n            if (\n                docClassTitle.content == \"book\" ||\n                docClassTitle.content == \"memoir\"\n            ) {\n                isBook = true;\n            }\n        }\n    }\n\n    // if we still don't know if it's a book, look for _chapters environments (since breakonboundaries was called before)\n    if (!isBook) {\n        visit(tree, (node) => {\n            if (anyEnvironment(node) && node.env == \"_chapter\") {\n                isBook = true;\n                return EXIT;\n            }\n        });\n    }\n\n    // a book and article tag must have a title tag right after it\n    // extract the title first\n    const title = findMacro(tree, \"title\");\n\n    if (title) {\n        const titleArg = getArgsContent(title)[1];\n\n        // get the actual title\n        if (titleArg) {\n            const titleString = titleArg[0] as Ast.String;\n            tree.content.unshift(\n                htmlLike({ tag: \"title\", content: titleString })\n            );\n        }\n        // if no title name was given, make an empty tag\n        else {\n            tree.content.unshift(htmlLike({ tag: \"title\", content: s(\"\") }));\n        }\n    }\n    // if there is no title, add an empty title tag\n    else {\n        tree.content.unshift(htmlLike({ tag: \"title\", content: s(\"\") }));\n    }\n\n    // now create a book or article tag\n    if (isBook) {\n        tree.content = [htmlLike({ tag: \"book\", content: tree.content })];\n    } else {\n        tree.content = [htmlLike({ tag: \"article\", content: tree.content })];\n    }\n}\n\n// this will likely be removed\nfunction findMacro(tree: Ast.Root, content: string): Ast.Macro | null {\n    let macro: Ast.Macro | null = null;\n\n    // look for the macro\n    visit(tree, (node) => {\n        // skip visiting the children of environments\n        if (anyEnvironment(node)) {\n            return SKIP;\n        }\n        if (anyMacro(node) && node.content === content) {\n            macro = node;\n            return EXIT;\n        }\n    });\n\n    return macro;\n}\n","import * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    expandMacrosExcludingDefinitions,\n    listNewcommands,\n} from \"@unified-latex/unified-latex-util-macros\";\nimport { attachMacroArgs } from \"@unified-latex/unified-latex-util-arguments\";\nimport { anyMacro } from \"@unified-latex/unified-latex-util-match\";\nimport { EXIT, visit } from \"@unified-latex/unified-latex-util-visit\";\n\ntype NewCommandSpec = ReturnType<typeof listNewcommands>[number];\n\n/**\n * Expands user-defined macros\n */\nexport function expandUserDefinedMacros(ast: Ast.Ast): void {\n    const newcommands = listNewcommands(ast);\n\n    // get a set of all macros to be expanded\n    const macrosToExpand = new Set(newcommands.map((command) => command.name));\n\n    const macroInfo = Object.fromEntries(\n        newcommands.map((m) => [m.name, { signature: m.signature }])\n    );\n\n    // recursively expand at most 100 times\n    for (let i = 0; i < 100; i++) {\n        // check if any macros still need expanding\n        if (!needToExpand(ast, macrosToExpand)) {\n            break;\n        }\n\n        // attach the arguments to each macro before processing it\n        attachMacroArgs(ast, macroInfo);\n        expandMacrosExcludingDefinitions(ast, newcommands);\n    }\n}\n\nfunction needToExpand(ast: Ast.Ast, macros: Set<string>): boolean {\n    let needExpand = false;\n\n    visit(ast, (node) => {\n        if (anyMacro(node) && macros.has(node.content)) {\n            needExpand = true;\n            EXIT;\n        }\n    });\n\n    return needExpand;\n}\n","import * as Xast from \"xast\";\nimport { x } from \"xastscript\";\nimport { Plugin, unified } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { TypeGuard } from \"@unified-latex/unified-latex-types\";\nimport { expandUnicodeLigatures } from \"@unified-latex/unified-latex-util-ligatures\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { EXIT, visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { toPretextWithLoggerFactory } from \"./pretext-subs/to-pretext\";\nimport {\n    unifiedLatexToPretextLike,\n    PluginOptions as HtmlLikePluginOptions,\n} from \"./unified-latex-plugin-to-pretext-like\";\nimport { expandUserDefinedMacros } from \"./pre-conversion-subs/expand-user-defined-macros\";\n\nexport type PluginOptions = HtmlLikePluginOptions & {\n    /**\n     * A boolean where if it's true then the output won't be wrapped in the <pretext><article> ... etc. tags.\n     * If it's false (default), a valid and complete PreTeXt document is returned.\n     */\n    producePretextFragment?: boolean;\n};\n\n/**\n * Unified plugin to convert a `unified-latex` AST into a `xast` AST representation of PreTeXt source.\n */\nexport const unifiedLatexToPretext: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Xast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    return (tree, file) => {\n        const producePretextFragment = options?.producePretextFragment\n            ? options?.producePretextFragment\n            : false;\n\n        // expand user defined macros\n        expandUserDefinedMacros(tree);\n\n        // If there is a \\begin{document}...\\end{document}, that's the only\n        // content we want to convert.\n        let content = tree.content;\n        visit(\n            tree,\n            (env) => {\n                content = env.content;\n                return EXIT;\n            },\n            {\n                test: ((node) =>\n                    match.environment(\n                        node,\n                        \"document\"\n                    )) as TypeGuard<Ast.Environment>,\n            }\n        );\n\n        // since we don't want to wrap content outside of \\begin{document}...\\end{document} with <pretext>...</pretext>\n        tree.content = content;\n\n        unified().use(unifiedLatexToPretextLike, options).run(tree, file);\n\n        // This should happen right before converting to PreTeXt because macros like `\\&` should\n        // be expanded via html rules first (and not turned into their corresponding ligature directly)\n        expandUnicodeLigatures(tree);\n\n        // update content\n        content = tree.content;\n\n        const toXast = toPretextWithLoggerFactory(file.message.bind(file));\n        let converted = toXast({ type: \"root\", content });\n        if (!Array.isArray(converted)) {\n            converted = [converted];\n        }\n        // Wrap everything in a Xast.Root node\n        let ret = x();\n        ret.children = converted;\n\n        // add boilerplate\n        if (!producePretextFragment) {\n            ret.children.unshift({\n                type: \"instruction\",\n                name: \"xml\",\n                value: \"version='1.0' encoding='utf-8'\",\n            });\n        }\n        return ret;\n    };\n};\n","/**\n * @typedef CoreOptions\n * @property {ReadonlyArray<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\nconst defaultSubsetRegex = /[\"&'<>`]/g\nconst surrogatePairsRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\nconst controlCharactersRegex =\n  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n  /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g\nconst regexEscapeRegex = /[|\\\\{}()[\\]^$+*?.]/g\n\n/** @type {WeakMap<ReadonlyArray<string>, RegExp>} */\nconst subsetToRegexCache = new WeakMap()\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset\n      ? charactersToExpressionCached(options.subset)\n      : defaultSubsetRegex,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(surrogatePairsRegex, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(controlCharactersRegex, basic)\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * A wrapper function that caches the result of `charactersToExpression` with a WeakMap.\n * This can improve performance when tooling calls `charactersToExpression` repeatedly\n * with the same subset.\n *\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpressionCached(subset) {\n  let cached = subsetToRegexCache.get(subset)\n\n  if (!cached) {\n    cached = charactersToExpression(subset)\n    subsetToRegexCache.set(subset, cached)\n  }\n\n  return cached\n}\n\n/**\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(regexEscapeRegex, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n","/**\n * The smallest way to encode a character.\n *\n * @param {number} code\n * @returns {string}\n */\nexport function formatBasic(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n","import {stringifyEntitiesLight} from 'stringify-entities'\n\n// eslint-disable-next-line no-control-regex -- XO is wrong.\nconst noncharacter = /[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F]/g\n\n/**\n * Escape a string.\n *\n * @param {string} value\n *   Raw string.\n * @param {Array<string>} subset\n *   Characters to escape.\n * @param {RegExp | null | undefined} [unsafe]\n *   Regex to scope `subset` to (optional).\n * @returns {string}\n *   Escaped string.\n */\nexport function escape(value, subset, unsafe) {\n  const result = clean(value)\n\n  return unsafe ? result.replace(unsafe, encode) : encode(result)\n\n  /**\n   * Actually escape characters.\n   *\n   * @param {string} value\n   *   Raw value.\n   * @returns {string}\n   *   Copy of `value`, escaped.\n   */\n  function encode(value) {\n    return stringifyEntitiesLight(value, {subset})\n  }\n}\n\n/**\n * Remove non-characters.\n *\n * @param {string} value\n *   Raw value.\n * @returns {string}\n *   Copy of `value` with non-characters removed.\n */\nfunction clean(value) {\n  return String(value || '').replace(noncharacter, '')\n}\n","/**\n * @typedef {import('xast').Cdata} Cdata\n */\n\nimport {escape} from './util-escape.js'\n\nconst unsafe = /]]>/g\nconst subset = ['>']\n\n/**\n * Serialize a CDATA section.\n *\n * @param {Cdata} node\n *   xast cdata node.\n * @returns {string}\n *   Serialized XML.\n */\nexport function cdata(node) {\n  return '<![CDATA[' + escape(node.value, subset, unsafe) + ']]>'\n}\n","/**\n * @typedef {import('xast').Comment} Comment\n */\n\nimport {escape} from './util-escape.js'\n\n/**\n * Serialize a comment.\n *\n * @param {Comment} node\n *   xast comment node.\n * @returns {string}\n *   Serialized XML.\n */\nexport function comment(node) {\n  return '<!--' + escape(node.value, ['-']) + '-->'\n}\n","import {escape} from './util-escape.js'\n\nconst subset = ['\\t', '\\n', ' ', '\"', '&', \"'\", '/', '<', '=', '>']\n\n/**\n * Encode a node name.\n *\n * @param {string} value\n *   Raw name.\n * @returns {string}\n *   Escaped name.\n */\nexport function name(value) {\n  return escape(value, subset)\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef {import('./index.js').State} State\n */\n\nimport {ccount} from 'ccount'\nimport {escape} from './util-escape.js'\n\n/**\n * Serialize an attribute value.\n *\n * @param {string} value\n *   Raw attribute value.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized attribute value.\n */\nexport function value(value, state) {\n  const result = String(value)\n  let quote = state.options.quote || '\"'\n\n  if (state.options.quoteSmart) {\n    const other = quote === '\"' ? \"'\" : '\"'\n\n    if (ccount(result, quote) > ccount(result, other)) {\n      quote = other\n    }\n  }\n\n  return quote + escape(result, ['<', '&', quote]) + quote\n}\n","/**\n * @typedef {import('xast').Doctype} Doctype\n * @typedef {import('./index.js').State} State\n */\n\nimport {name} from './name.js'\nimport {value} from './value.js'\n\n/**\n * Serialize a doctype.\n *\n * @param {Doctype} node\n *   xast doctype node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function doctype(node, state) {\n  const nodeName = name(node.name)\n  const pub = node.public\n  const sys = node.system\n  let result = '<!DOCTYPE'\n\n  if (nodeName !== '') {\n    result += ' ' + nodeName\n  }\n\n  if (pub) {\n    result += ' PUBLIC ' + value(pub, state)\n  } else if (sys) {\n    result += ' SYSTEM'\n  }\n\n  if (sys) {\n    result += ' ' + value(sys, state)\n  }\n\n  return result + '>'\n}\n","/**\n * @typedef {import('xast').Element} Element\n * @typedef {import('./index.js').State} State\n */\n\nimport {name} from './name.js'\nimport {all} from './one.js'\nimport {value} from './value.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Serialize an element.\n *\n * @param {Element} node\n *   xast element node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function element(node, state) {\n  const nodeName = name(node.name)\n  const content = all(node, state)\n  const attributes = node.attributes || {}\n  const close = content ? false : state.options.closeEmptyElements\n  /** @type {Array<string>} */\n  const attrs = []\n  /** @type {string} */\n  let key\n\n  for (key in attributes) {\n    if (own.call(attributes, key)) {\n      const result = attributes[key]\n\n      if (result !== null && result !== undefined) {\n        attrs.push(name(key) + '=' + value(result, state))\n      }\n    }\n  }\n\n  return (\n    '<' +\n    nodeName +\n    (attrs.length === 0 ? '' : ' ' + attrs.join(' ')) +\n    (close ? (state.options.tightClose ? '' : ' ') + '/' : '') +\n    '>' +\n    content +\n    (close ? '' : '</' + nodeName + '>')\n  )\n}\n","/**\n * @typedef {import('xast').Instruction} Instruction\n */\n\nimport {name} from './name.js'\nimport {escape} from './util-escape.js'\n\nconst unsafe = /\\?>/g\nconst subset = ['>']\n\n/**\n * Serialize an instruction.\n *\n * @param {Instruction} node\n *   xast instruction node.\n * @returns {string}\n *   Serialized XML.\n */\nexport function instruction(node) {\n  const nodeName = name(node.name) || 'x'\n  const result = escape(node.value, subset, unsafe)\n  return '<?' + nodeName + (result ? ' ' + result : '') + '?>'\n}\n","/**\n * @typedef {import('xast').Text} Text\n * @typedef {import('../index.js').Raw} Raw\n */\n\nimport {escape} from './util-escape.js'\n\nconst subset = ['&', '<']\n\n/**\n * Serialize a text.\n *\n * @param {Raw | Text} node\n *   xast text node (or raw).\n * @returns {string}\n *   Serialized XML.\n */\nexport function text(node) {\n  return escape(node.value, subset)\n}\n","/**\n * @typedef {import('../index.js').Raw} Raw\n * @typedef {import('./index.js').State} State\n */\n\nimport {text} from './text.js'\n\n/**\n * Serialize a (non-standard) raw.\n *\n * @param {Raw} node\n *   xast raw node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function raw(node, state) {\n  return state.options.allowDangerousXml ? node.value : text(node)\n}\n","/**\n * @typedef {import('xast').Nodes} Nodes\n * @typedef {import('xast').Parents} Parents\n * @typedef {import('xast').RootContent} RootContent\n * @typedef {import('./index.js').State} State\n */\n\nimport {cdata} from './cdata.js'\nimport {comment} from './comment.js'\nimport {doctype} from './doctype.js'\nimport {element} from './element.js'\nimport {instruction} from './instruction.js'\nimport {raw} from './raw.js'\nimport {text} from './text.js'\n\nconst own = {}.hasOwnProperty\n\nconst handlers = {\n  cdata,\n  comment,\n  doctype,\n  element,\n  instruction,\n  raw,\n  root: all,\n  text\n}\n\n/**\n * Serialize a node.\n *\n * @param {Nodes} node\n *   xast node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function one(node, state) {\n  const type = node && node.type\n\n  if (!type) {\n    throw new Error('Expected node, not `' + node + '`')\n  }\n\n  if (!own.call(handlers, type)) {\n    throw new Error('Cannot compile unknown node `' + type + '`')\n  }\n\n  const handle = handlers[type]\n  // @ts-expect-error hush, node matches `type`.\n  const result = handle(node, state)\n\n  return result\n}\n\n/**\n * Serialize all children of `parent`.\n *\n * @param {Parents} parent\n *   xast parent node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function all(parent, state) {\n  /** @type {Array<RootContent>} */\n  const children = (parent && parent.children) || []\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n\n  while (++index < children.length) {\n    results[index] = one(children[index], state)\n  }\n\n  return results.join('')\n}\n","/**\n * @typedef {import('xast').Literal} Literal\n * @typedef {import('xast').Nodes} Nodes\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [allowDangerousXml=false]\n *   Allow `raw` nodes and insert them as raw XML (default: `false`).\n *\n *   When `false`, `Raw` nodes are encoded.\n *\n *   > ‚ö†Ô∏è **Danger**: only set this if you completely trust the content.\n * @property {boolean | null | undefined} [closeEmptyElements=false]\n *   Close elements without any content with slash (`/`) on the opening tag\n *   instead of an end tag: `<circle />` instead of `<circle></circle>`\n *   (default: `false`).\n *\n *   See `tightClose` to control whether a space is used before the slash.\n * @property {Quote | null | undefined} [quote='\"']\n *   Preferred quote to use (default: `'\"'`).\n * @property {boolean | null | undefined} [quoteSmart=false]\n *   Use the other quote if that results in less bytes (default: `false`).\n * @property {boolean | null | undefined} [tightClose=false]\n *   Do not use an extra space when closing self-closing elements: `<circle/>`\n *   instead of `<circle />` (default: `false`).\n *\n *   > üëâ **Note**: only used if `closeEmptyElements: true`.\n *\n * @typedef {'\"' | \"'\"} Quote\n *   XML quotes for attribute values.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Options} options\n *   Configuration.\n */\n\nimport {one} from './one.js'\n\n/**\n * Serialize a xast tree to XML.\n *\n * @param {Array<Nodes> | Nodes} tree\n *   xast node(s) to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized XML.\n */\nexport function toXml(tree, options) {\n  /** @type {State} */\n  const state = {options: options || {}}\n\n  // Make sure the quote is valid.\n  if (\n    typeof state.options.quote === 'string' &&\n    state.options.quote !== '\"' &&\n    state.options.quote !== \"'\"\n  ) {\n    throw new Error(\n      'Invalid quote `' + state.options.quote + '`, expected `\\'` or `\"`'\n    )\n  }\n\n  /** @type {Nodes} */\n  // @ts-expect-error Assume no `root` in `node`.\n  const node = Array.isArray(tree) ? {type: 'root', children: tree} : tree\n\n  return one(node, state)\n}\n","import { toXml } from \"xast-util-to-xml\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { processLatexViaUnified } from \"@unified-latex/unified-latex\";\nimport {\n    unifiedLatexToPretext,\n    PluginOptions,\n} from \"./unified-latex-plugin-to-pretext\";\nimport { Plugin } from \"unified\";\nimport { Root } from \"xast\";\n\n/**\n * Unified plugin to convert a `XAST` AST to a string.\n */\nexport const xmlCompilePlugin: Plugin<void[], Root, string> = function () {\n    this.Compiler = toXml;\n};\n\nconst _processor = processLatexViaUnified()\n    .use(unifiedLatexToPretext)\n    .use(xmlCompilePlugin);\n\n/**\n * Convert the `unified-latex` AST `tree` into an HTML string. If you need\n * more precise control or further processing, consider using `unified`\n * directly with the `unifiedLatexToPretext` plugin.\n *\n * For example,\n * ```\n * unified()\n *      .use(unifiedLatexFromString)\n *      .use(unifiedLatexToPretext)\n *      .use(rehypeStringify)\n *      .processSync(\"\\\\LaTeX to convert\")\n * ```\n */\nexport function convertToPretext(\n    tree: Ast.Node | Ast.Node[],\n    options?: PluginOptions\n): string {\n    let processor = _processor;\n    if (!Array.isArray(tree) && tree.type !== \"root\") {\n        tree = { type: \"root\", content: [tree] };\n    }\n    if (Array.isArray(tree)) {\n        tree = { type: \"root\", content: tree };\n    }\n\n    if (options) {\n        processor = _processor.use(unifiedLatexToPretext, options);\n    }\n\n    const hast = processor.runSync(tree);\n    return processor.stringify(hast);\n}\n"],"names":["name","index","value","isBuffer","isArray","isPlainObject","setProperty","getProperty","extend","stringifyPosition","position","point","VFileMessage","path","assertPath","prop","dirname","basename","extname","bufferLike","own","options","isPlainObj","file","s","match","x","replaceNode","anyMacro","visit","anyEnvironment","splitOnMacro","unsplitOnMacro","getNamedArgsContent","arg","env","printRaw","toPretext","isHtmlLikeTag","extractFromHtmlLike","getArgsContent","trim","htmlLike","parseAlignEnvironment","parseTabularSpec","systemeContentsToArray","attachSystemeSettingsAsRenderInfo","factory","m","colorToTextcolorMacro","unifiedLatexWrapPars","macroReplacements","_macroReplacements","environmentReplacements","_environmentReplacements","deleteComments","unifiedLatexLintNoTexFontShapingCommands","unifiedLatexReplaceStreamingCommands","EXIT","SKIP","listNewcommands","attachMacroArgs","expandMacrosExcludingDefinitions","expandUnicodeLigatures","all","subset","unsafe","processLatexViaUnified"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46]}